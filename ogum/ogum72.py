# -*- coding: utf-8 -*-
"""Ogum Sintering Complete 7.2 - June Calculations

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bFGCt30N8yF4VbRRRQ1EKZZa9KKllN1I
"""

# ==============================================================================
# MÓDULO CORE
# Contém constantes, classes de dados e funções utilitárias compartilhadas
# por toda a aplicação.
# ==============================================================================

# ----------------------------------------
# Importações de Bibliotecas Padrão
# ----------------------------------------
import os
import base64
import copy
import datetime
from pathlib import Path
from uuid import uuid4
from io import BytesIO
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from collections import defaultdict

# ----------------------------------------
# Importações de Bibliotecas de Terceiros
# ----------------------------------------
import numpy as np
import pandas as pd
import ipywidgets as widgets
from IPython.display import display, HTML

# Funções do SciPy
from scipy.signal import savgol_filter
from scipy.interpolate import interp1d
from scipy.optimize import curve_fit, minimize_scalar
from scipy.stats import linregress
# Usa 'cumulative_trapezoid' para compatibilidade com SciPy >=1.14 e alias como cumtrapz
from scipy.integrate import cumulative_trapezoid as cumtrapz

# ==============================================================================
# Constantes Globais
# ==============================================================================
R = 8.314  # Constante universal dos gases (J/mol.K)

# ==============================================================================
# Estruturas de Dados Centrais
# ==============================================================================

@dataclass
class SinteringDataRecord:
    """
    Uma estrutura padronizada para armazenar um conjunto de dados de sinterização,
    seus metadados e parâmetros associados. Facilita a passagem de dados
    entre os diferentes módulos da aplicação.
    """
    ensaio_id: int
    Ea: float
    tipo_dado_y: str
    df: pd.DataFrame
    metadata: dict = field(default_factory=dict)

class DataHistory:
    """
    Classe para armazenar o histórico de estados de um DataFrame, permitindo
    operações de "undo" (desfazer) ao longo do processamento.
    """
    def __init__(self):
        self.history: List[Dict[str, Any]] = []

    def push(self, data: pd.DataFrame, module_name: str):
        """Adiciona uma cópia do estado atual dos dados ao histórico."""
        record = {
            'timestamp': datetime.datetime.now(),
            'module': module_name,
            'columns': list(data.columns),
            'data': copy.deepcopy(data)
        }
        self.history.append(record)

    def pop(self) -> Optional[Dict[str, Any]]:
        """Remove e retorna o último estado salvo no histórico."""
        return self.history.pop() if self.history else None

    def peek(self) -> Optional[Dict[str, Any]]:
        """Visualiza o último estado salvo sem removê-lo."""
        return self.history[-1] if self.history else None

    def get_all(self) -> List[Dict[str, Any]]:
        """Retorna uma cópia de todo o histórico."""
        return list(self.history)

# ==============================================================================
# Funções Utilitárias da Interface
# ==============================================================================

def add_suffix_once(col: str, suffix: str) -> str:
    """Retorna a string 'col' com o 'suffix' adicionado, se ela ainda não o possuir."""
    return col if col.endswith(suffix) else f"{col}{suffix}"

# ... (demais funções como criar_titulo, exibir_mensagem, exibir_erro, etc.)

def criar_titulo(texto: str, nivel: int = 2) -> widgets.HTML:
    return widgets.HTML(f"<h{nivel}>{texto}</h{nivel}>")

def exibir_mensagem(msg: str):
    display(HTML(f"<p style='color:blue; font-style:italic;'>{msg}</p>"))

def exibir_erro(msg: str):
    display(HTML(f"<p style='color:red; font-weight:bold;'>ERRO: {msg}</p>"))

def criar_caixa_colapsavel(titulo: str, conteudo: widgets.Widget, aberto: bool = False) -> widgets.Accordion:
    acc = widgets.Accordion(children=[conteudo])
    acc.set_title(0, titulo)
    if not aberto:
        acc.selected_index = None
    return acc

def gerar_link_download(df: pd.DataFrame, nome_arquivo: str = "dados.xlsx") -> HTML:
    uid = uuid4().hex[:6]
    stem = Path(nome_arquivo).stem
    final_name = f"{stem}_{uid}.xlsx"
    output = BytesIO()
    with pd.ExcelWriter(output, engine="openpyxl") as writer:
        df.to_excel(writer, index=False)
    b64 = base64.b64encode(output.getvalue()).decode()
    return HTML(f'<a download="{final_name}" href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" target="_blank">Clique aqui para baixar: {final_name}</a>')

# ==============================================================================
# Modelos Matemáticos
# ==============================================================================

def boltzmann_sigmoid(x, A1, A2, x0, dx):
    exp_term = np.exp(np.clip((x - x0) / dx, -700, 700))
    return A2 + (A1 - A2) / (1 + exp_term)

def generalized_logistic_stable(x, A1, A2, x0, b, c):
    z = -(x - x0) / b
    log_1_plus_exp_z = np.where(z > 30, z, np.log1p(np.exp(z)))
    denominator = np.exp(c * log_1_plus_exp_z)
    return A2 + (A1 - A2) / (denominator + 1e-12)
import sys
sys.modules['core'] = sys.modules[__name__]

# MÓDULO 1_Interface
# modulo1_interface.py

import numpy as np
import ipywidgets as widgets
import core
from typing import List  # <-- Adicionado para corrigir o NameError

class EaSelectionWidget:
    """Widget reutilizável para selecionar Energias de Ativação (Ea)."""
    def __init__(self):
        self._build_ui()

    def _build_ui(self):
        self.radio_energy_choice = widgets.RadioButtons(
            options=[("Discretas", "discretas"), ("Intervalo", "intervalo")],
            value="discretas",
            description="Modo de Seleção de Ea:",
            style={'description_width': 'initial'}
        )
        self.dropdown_num_energies = widgets.Dropdown(
            options=[(f"{i} energias", i) for i in range(1, 11)],
            value=3,
            description="Quantidade:"
        )
        self.btn_energy_add = widgets.Button(description="Gerar Campos", button_style='info')
        self.energies_box = widgets.VBox([])
        self.float_min = widgets.FloatText(value=100.0, description="Ea Mín (kJ/mol):")
        self.float_max = widgets.FloatText(value=2000.0, description="Ea Máx (kJ/mol):")
        self.num_points = widgets.IntText(value=20, description="Nº de Pontos:")

        self.discretas_container = widgets.VBox([
            self.dropdown_num_energies,
            self.btn_energy_add,
            self.energies_box
        ])
        self.intervalo_container = widgets.VBox(
            [self.float_min, self.float_max, self.num_points],
            layout={'display': 'none'}
        )

        self.radio_energy_choice.observe(self._on_energy_choice_changed, names='value')
        self.btn_energy_add.on_click(self._on_add_energies)
        self._on_add_energies(None)

        self.ui = widgets.VBox([
            widgets.HTML("<b>Definir Energias de Ativação (Ea) para Análise</b>"),
            self.radio_energy_choice,
            self.discretas_container,
            self.intervalo_container
        ])

    def _on_energy_choice_changed(self, change):
        is_discrete = change['new'] == "discretas"
        self.discretas_container.layout.display = '' if is_discrete else 'none'
        self.intervalo_container.layout.display = 'none' if is_discrete else ''

    def _on_add_energies(self, _):
        n = self.dropdown_num_energies.value
        self.energies_box.children = [
            widgets.FloatText(
                value=round(100.0 + 50 * i, 1),
                description=f"Ea {i+1} (kJ/mol):"
            )
            for i in range(n)
        ]

    def get_ea_list(self) -> List[float]:
        if self.radio_energy_choice.value == "discretas":
            values = [ft.value for ft in self.energies_box.children if ft.value > 0]
            if not values:
                core.exibir_erro("Nenhuma energia válida informada no modo 'Discretas'.")
                return []
            return sorted(set(values))
        else:
            ea_min = self.float_min.value
            ea_max = self.float_max.value
            n_pts = self.num_points.value
            if ea_max <= ea_min or n_pts < 2:
                core.exibir_erro(
                    "No modo 'Intervalo', Ea Máx > Ea Mín e Nº de Pontos >= 2."
                )
                return []
            return list(np.linspace(ea_min, ea_max, n_pts))

import sys
sys.modules['modulo1_interface'] = sys.modules[__name__]

# MÓDULO 2_Importação
import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
from io import BytesIO

# Importando do seu arquivo core
from core import (
    DataHistory, criar_titulo, exibir_mensagem, exibir_erro, add_suffix_once
)

class Modulo2Importacao:
    """
    Módulo 2 – Importação de Dados.
    Gerencia o upload, mapeamento e conversão inicial dos dados experimentais.
    """
    def __init__(self):
        self.n_ensaios = 1
        self.dfs_ensaios = [None] * 4  # Suporta até 4 ensaios
        self.file_uploads = []
        self.history = DataHistory()
        self._build_ui()

    def _build_ui(self):
        self.title_label = criar_titulo("Módulo 2 – Importação e Reconhecimento de Dados", nivel=2)

        intro_text = """
        <div style="font-family: Arial, sans-serif; line-height: 1.5;">
            <p>Neste módulo, os dados experimentais são carregados a partir de arquivos .xlsx.
            É fundamental que cada arquivo contenha colunas para <b>Tempo</b>, <b>Temperatura</b> e um parâmetro de sinterização (<b>Densidade</b> ou <b>Retração</b>).</p>
        </div>
        """
        self.intro_widget = widgets.HTML(value=intro_text)

        self.dropdown_ensaios = widgets.Dropdown(
            options=[(f"{i} Teste{'s' if i > 1 else ''}", i) for i in range(1, 5)],
            value=1, description="Número de testes:"
        )
        self.btn_confirm_ensaios = widgets.Button(description="Confirmar Qtd.", button_style='success')
        self.btn_confirm_ensaios.on_click(self._confirmar_num_ensaios)

        self.upload_box = widgets.VBox([])
        self.out = widgets.Output()

        self.main_ui = widgets.VBox([
            self.title_label, self.intro_widget,
            widgets.HBox([self.dropdown_ensaios, self.btn_confirm_ensaios]),
            self.upload_box, self.out
        ])

        # Gera a UI para 1 ensaio por padrão na inicialização
        self._confirmar_num_ensaios(None)

    def _confirmar_num_ensaios(self, _=None):
        with self.out: clear_output()
        self.n_ensaios = self.dropdown_ensaios.value
        exibir_mensagem(f"{self.n_ensaios} teste(s) selecionado(s).")

        self.upload_box.children = []
        self.file_uploads = []

        for i in range(self.n_ensaios):
            uploader = widgets.FileUpload(accept='.xlsx', multiple=False, description="Upload .xlsx")
            out_local = widgets.Output()
            map_box = widgets.VBox([])
            map_confirm_btn = widgets.Button(description="Confirmar Mapeamento", button_style='success', layout={'display': 'none'})

            conv_panel = widgets.VBox([
                widgets.HTML("<b>Parâmetros de Conversão (Retração -> Densidade)</b>"),
                widgets.FloatText(value=10.0, description="Tamanho Inicial (mm):"),
                widgets.FloatText(value=55.0, description="Densidade Inicial (%):"),
                widgets.FloatText(value=95.0, description="Densidade Final (%):")
            ])
            conv_params = {
                "tamanho_inicial": conv_panel.children[1],
                "dens_inicial": conv_panel.children[2],
                "dens_final": conv_panel.children[3]
            }
            btn_convert = widgets.Button(description="Converter para Densidade", button_style='warning')

            upload_info = {
                "uploader": uploader, "out_local": out_local, "map_box": map_box,
                "map_confirm_btn": map_confirm_btn, "conv_params": conv_params, "btn_convert": btn_convert
            }
            self.file_uploads.append(upload_info)

            uploader.observe(self._on_load_data(i), names='value')
            map_confirm_btn.on_click(self._on_confirm_mapping(i))
            btn_convert.on_click(self._on_convert(i))

            vbox_ensaio = widgets.VBox([
                widgets.HTML(f"<hr><b>Teste {i+1}</b>"), uploader, out_local,
                map_box, map_confirm_btn, conv_panel, btn_convert
            ])
            self.upload_box.children += (vbox_ensaio,)

    def _on_load_data(self, idx):
        def _cb(change):
            w = self.file_uploads[idx]
            with w["out_local"]:
                clear_output(wait=True)
                if not change.new: return
                try:
                    file_info = next(iter(change.new.values()))
                    content = file_info['content']
                    df = pd.read_excel(BytesIO(content))
                    self.dfs_ensaios[idx] = df
                    exibir_mensagem(f"Arquivo carregado com {len(df)} linhas. Colunas: {df.columns.tolist()}")
                    self._create_mapping_ui_for_ensaio(idx, df)
                except Exception as e:
                    exibir_erro(f"Erro ao ler arquivo: {e}")
        return _cb

    def _create_mapping_ui_for_ensaio(self, idx, df):
        w = self.file_uploads[idx]
        options = [
            ('Ignorar', 'ignore'), ('Tempo (s)', 'Time_s'), ('Tempo (min)', 'Time_min'),
            ('Tempo (h)', 'Time_h'), ('Temperatura (°C)', 'Temperature_C'),
            ('Retração Absoluta (mm)', 'RetracaoAbs'), ('Retração Percentual (%)', 'RetracaoPct'),
            ('Retração Relativa (ΔL/L₀)', 'RetracaoRel'), ('Densidade Percentual (%)', 'DensidadePct')
        ]
        w["map_box"].children = [widgets.Dropdown(options=options, value='ignore', description=col) for col in df.columns]
        w["map_confirm_btn"].layout.display = ''

    def _on_confirm_mapping(self, idx):
        def _cb(_):
            w = self.file_uploads[idx]
            with w["out_local"]:
                clear_output(wait=True)
                df = self.dfs_ensaios[idx]
                if df is None: exibir_erro("DataFrame não carregado."); return

                try:
                    rename_dict = {dd.description: dd.value for dd in w["map_box"].children if dd.value != 'ignore'}

                    # Reintroduz a validação de tempo ambíguo
                    time_mappings = [v for v in rename_dict.values() if v.startswith('Time_')]
                    if len(time_mappings) > 1:
                        raise ValueError(f"Mapeamento de tempo ambíguo. Selecione apenas um tipo de tempo. Encontrados: {time_mappings}")

                    df_temp = df[list(rename_dict.keys())].rename(columns=rename_dict).copy()

                    if 'Time_min' in df_temp.columns: df_temp['Time_s'] = df_temp.pop('Time_min') * 60
                    elif 'Time_h' in df_temp.columns: df_temp['Time_s'] = df_temp.pop('Time_h') * 3600

                    if not any(c.startswith('Time') for c in df_temp.columns) or \
                       not any(c.startswith('Temp') for c in df_temp.columns) or \
                       not any(c.startswith('Dens') or c.startswith('Retracao') for c in df_temp.columns):
                        raise ValueError("Mapeamento incompleto. Verifique se Tempo, Temperatura e Densidade/Retração foram mapeados.")

                    df_temp.columns = [add_suffix_once(c, f"_e{idx+1}") for c in df_temp.columns]
                    self.dfs_ensaios[idx] = df_temp
                    exibir_mensagem(f"Mapeamento salvo. Colunas finais: {df_temp.columns.tolist()}")
                    self.history.push(df_temp, f"M2:Mapeamento:{idx}")
                except Exception as e:
                    exibir_erro(f"{e}")
        return _cb

    def _on_convert(self, idx):
        def _cb(_):
            w = self.file_uploads[idx]
            with w["out_local"]:
                clear_output(wait=True)
                df = self.dfs_ensaios[idx]
                if df is None or df.empty: exibir_erro("Dados não mapeados."); return

                params = w["conv_params"]
                di, df_final, lo = params["dens_inicial"].value, params["dens_final"].value, params["tamanho_inicial"].value
                target_col = f"DensidadePct_e{idx+1}"

                if target_col in df.columns: exibir_mensagem("Dados já convertidos."); return

                df_temp = df.copy()
                try:
                    found_col, retracao_rel = None, None
                    prefixes = [('RetracaoRel', 1), ('RetracaoPct', 100.0), ('RetracaoAbs', lo)]
                    for prefix, divisor in prefixes:
                        col_name = f"{prefix}_e{idx+1}"
                        if col_name in df_temp:
                            if prefix == 'RetracaoAbs' and lo <= 0: raise ValueError("Tamanho inicial (lo) deve ser > 0.")
                            retracao_rel = df_temp[col_name] / divisor
                            found_col = col_name
                            break

                    if found_col is None: raise ValueError("Nenhuma coluna de retração encontrada para converter.")

                    df_temp[target_col] = di / (1 + retracao_rel)**3
                    min_calc, max_calc = df_temp[target_col].min(), df_temp[target_col].max()
                    if max_calc > min_calc:
                        df_temp[target_col] = di + (df_temp[target_col] - min_calc) * (df_final - di) / (max_calc - min_calc)

                    df_temp.drop(columns=[found_col], inplace=True)
                    self.dfs_ensaios[idx] = df_temp
                    exibir_mensagem(f"Conversão concluída. Coluna '{found_col}' substituída por '{target_col}'.")
                    self.history.push(df_temp, f"M2:Conversao:{idx}")
                except Exception as e:
                    exibir_erro(f"Erro na conversão: {e}")
        return _cb

    def validar_etapa(self) -> bool:
        """
        Verifica se todos os ensaios selecionados foram completamente processados.
        Retorna True se tudo estiver OK, False caso contrário.
        """
        with self.out:
            clear_output(wait=True)
        all_ok = True
        for i in range(self.n_ensaios):
            df = self.dfs_ensaios[i]
            if df is None or df.empty:
                exibir_erro(f"Teste {i+1}: Dados não foram carregados ou mapeados.")
                all_ok = False
                continue

            # Verifica se a conversão para densidade foi feita
            if not any(c.startswith(f"DensidadePct_e{i+1}") for c in df.columns):
                exibir_erro(f"Teste {i+1}: Dados não foram convertidos para densidade. Clique em 'Converter para Densidade'.")
                all_ok = False

        if all_ok:
            exibir_mensagem("Validação da Etapa 1 concluída com sucesso!")
        return all_ok

    def get_dfs(self):
        return self.dfs_ensaios[:self.n_ensaios]

import sys
sys.modules['modulo2_importacao'] = sys.modules[__name__]

import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
from scipy.interpolate import interp1d, PchipInterpolator, Akima1DInterpolator
import sys # Importa a biblioteca sys

# Importando do seu arquivo core
from core import (
    DataHistory, exibir_mensagem, exibir_erro, gerar_link_download
)

def orlandini_araujo_filter(df: pd.DataFrame, bin_size: int = 10) -> pd.DataFrame:
    """
    Aplica o filtro de Orlandini-Araújo, agregando dados em intervalos de tempo.
    Esta versão é mais robusta, aplicando 'mean' a colunas numéricas e 'first' a não-numéricas.
    """
    time_col = next((col for col in df.columns if col.startswith('Time_s')), None)
    if not time_col:
        raise ValueError("Coluna de tempo (Time_s*) não encontrada para o filtro Orlandini-Araújo.")

    dfc = df.copy()
    dfc['bin'] = np.floor(dfc[time_col] / bin_size).astype(int)

    agg_dict = {
        col: 'mean' if pd.api.types.is_numeric_dtype(df[col]) else 'first'
        for col in df.columns if col != 'bin'
    }

    grouped = dfc.groupby('bin').agg(agg_dict).reset_index(drop=True)
    return grouped

class Modulo3Recorte:
    """
    Módulo 3 - Recorte de Dados, Ajuste de Tempo, Visualização e Filtragem.
    """
    def __init__(self, dfs_ensaios: list):
        self.dfs_ensaios = [df.copy() for df in dfs_ensaios if df is not None and not df.empty]
        self.n_ensaios = len(self.dfs_ensaios)
        self.history = DataHistory()
        self._build_ui()

    def _build_ui(self):
        if self.n_ensaios == 0:
            self.main_ui = widgets.HTML("<b>Nenhum ensaio válido recebido do Módulo 2.</b>")
            return

        panels = [self._build_ensaio_panel(i) for i in range(self.n_ensaios)]
        self.accordion = widgets.Accordion(children=panels)
        for i in range(self.n_ensaios):
            self.accordion.set_title(i, f"Ensaio {i+1}")

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Módulo 3 - Recorte e Filtragem</h3>"),
            widgets.HTML("Ajuste o tempo, corte intervalos e aplique filtros para preparar os dados para análise."),
            self.accordion
        ])

    def _build_ensaio_panel(self, idx: int) -> widgets.HBox:
        log_out = widgets.Output()
        fig_out = widgets.Output(layout={'width': '50%'})

        # Controles
        radio_zerar = widgets.RadioButtons(options=[("Não", False), ("Sim", True)], description="Zerar Tempo?")
        btn_zerar = widgets.Button(description="Aplicar Ajuste", button_style='info')

        tmin, tmax = self._get_time_range(idx)
        slider_cut = widgets.FloatRangeSlider(value=(tmin, tmax), min=tmin, max=tmax, step=1.0, description='Corte (s):', continuous_update=False)
        btn_cut = widgets.Button(description="Aplicar Corte", button_style='info')

        filter_dd = widgets.Dropdown(
            options=[
                ('Nenhum', 'none'), ('Orlandini-Araujo', 'orlandini'), ('Savitzky-Golay', 'savgol'),
                ('Interpolação Linear', 'linear'), ('Interpolação Cúbica', 'cubic'),
                ('Interpolação PCHIP', 'pchip'), ('Interpolação Akima', 'akima')
            ], value='none', description='Filtro/Interp.:'
        )
        bin_widget = widgets.IntText(value=10, description="Bin (s):", layout={'display': 'none'})
        npoints_widget = widgets.IntText(value=200, description="Nº Pontos:", layout={'display': 'none'})
        btn_filter = widgets.Button(description="Aplicar Filtro", button_style='info')

        btn_plot = widgets.Button(description="Exibir Curvas", button_style='primary')
        btn_export = widgets.Button(description="Exportar Excel", button_style='primary')

        # Callbacks
        btn_zerar.on_click(lambda b: self._on_zerar_tempo(idx, radio_zerar.value, slider_cut, log_out))
        btn_cut.on_click(lambda b: self._on_corte_intervalo(idx, slider_cut.value, slider_cut, log_out))
        filter_dd.observe(lambda c: self._on_filter_change(c.new, bin_widget, npoints_widget), names='value')
        btn_filter.on_click(lambda b: self._on_aplicar_filtro(idx, filter_dd.value, bin_widget.value, npoints_widget.value, slider_cut, log_out))
        btn_plot.on_click(lambda b: self._on_plot(idx, fig_out, log_out))
        btn_export.on_click(lambda b: self._on_export(idx, log_out))

        # Layout
        controls = widgets.VBox([
            widgets.HTML("<b>Ajuste de Tempo</b>"), radio_zerar, btn_zerar,
            widgets.HTML("<hr><b>Corte de Intervalo</b>"), slider_cut, btn_cut,
            widgets.HTML("<hr><b>Filtragem / Interpolação</b>"), filter_dd, bin_widget, npoints_widget, btn_filter,
            widgets.HTML("<hr><b>Ações</b>"), widgets.HBox([btn_plot, btn_export]), log_out
        ], layout={'width': '50%'})

        return widgets.HBox([controls, fig_out])

    def _get_time_range(self, idx):
        df = self.dfs_ensaios[idx]
        time_col = next((c for c in df.columns if c.startswith('Time_s')), None)
        return (float(df[time_col].min()), float(df[time_col].max())) if time_col and not df.empty else (0.0, 100.0)

    def _update_slider_range(self, idx, slider):
        tmin, tmax = self._get_time_range(idx)
        slider.min, slider.max, slider.value = tmin, tmax, (tmin, tmax)

    def _on_zerar_tempo(self, idx, should_zero, slider, out):
        with out: clear_output(wait=True)
        dfi = self.dfs_ensaios[idx]
        time_col = next((c for c in dfi.columns if c.startswith('Time_s')), None)
        if not time_col: exibir_erro("Coluna de tempo não encontrada."); return

        if should_zero:
            min_t = dfi[time_col].min()
            dfi.loc[:, time_col] -= min_t
            dfi.sort_values(time_col, inplace=True)
            exibir_mensagem(f"Tempo zerado (subtraído {min_t:.2f} s).")

        self.dfs_ensaios[idx] = dfi.reset_index(drop=True)
        self.history.push(self.dfs_ensaios[idx], f"M3:ZerarTempo:{idx}")
        self._update_slider_range(idx, slider)

    def _on_corte_intervalo(self, idx, time_range, slider, out):
        with out: clear_output(wait=True)
        dfi = self.dfs_ensaios[idx]
        time_col = next((c for c in dfi.columns if c.startswith('Time_s')), None)
        if not time_col: exibir_erro("Coluna de tempo não encontrada."); return

        t_min, t_max = time_range
        mask = (dfi[time_col] >= t_min) & (dfi[time_col] <= t_max)
        df_cut = dfi[mask].copy().reset_index(drop=True)

        exibir_mensagem(f"Corte aplicado. Mantidos {len(df_cut)} de {len(dfi)} pontos.")
        self.dfs_ensaios[idx] = df_cut
        self.history.push(df_cut, f"M3:Corte:{idx}")
        self._update_slider_range(idx, slider)

    def _on_filter_change(self, method, bin_w, npoints_w):
        bin_w.layout.display = '' if method == 'orlandini' else 'none'
        npoints_w.layout.display = '' if method in ('linear', 'cubic', 'pchip', 'akima') else 'none'

    def _on_aplicar_filtro(self, idx, method, bin_size, n_points, slider, out):
        with out: clear_output(wait=True)
        try:
            dfi = self.dfs_ensaios[idx]

            essential_cols = [
                next((c for c in dfi.columns if c.startswith(prefix)), None)
                for prefix in ['Time_s', 'Temperature_C', 'DensidadePct']
            ]
            if not all(essential_cols):
                raise ValueError("Faltam colunas essenciais (Tempo, Temperatura, Densidade) para aplicar o filtro.")

            original_len = len(dfi)
            df_clean = dfi.dropna(subset=essential_cols).copy()
            if len(df_clean) < original_len:
                exibir_mensagem(f"{original_len - len(df_clean)} linhas com valores nulos foram removidas.")

            if method == 'none':
                exibir_mensagem("Nenhum filtro aplicado."); return

            if method == 'orlandini':
                df_filtered = orlandini_araujo_filter(df_clean, bin_size=bin_size)
                exibir_mensagem(f"Filtro Orlandini-Araujo aplicado (bin={bin_size}s).")

            elif method == 'savgol':
                df_filtered = df_clean.copy()
                w = min(11, (len(df_clean) // 2) * 2 + 1)
                if w < 5: raise ValueError("Pontos insuficientes para Savitzky-Golay.")

                for col in df_filtered.select_dtypes(include=np.number).columns:
                    df_filtered.loc[:, col] = savgol_filter(df_filtered[col].values, w, 2)
                exibir_mensagem(f"Filtro Savitzky-Golay aplicado (janela={w}).")

            elif method in ('linear', 'cubic', 'pchip', 'akima'):
                time_col = essential_cols[0]
                dfu = df_clean.drop_duplicates(subset=[time_col]).sort_values(time_col)
                if len(dfu) < 4 and method in ('cubic', 'pchip', 'akima'):
                    raise ValueError(f"Pontos insuficientes ({len(dfu)}) para interpolação '{method}'.")

                new_time = np.linspace(dfu[time_col].min(), dfu[time_col].max(), n_points)
                new_data = {time_col: new_time}

                for col in dfu.select_dtypes(include=np.number).columns:
                    if col == time_col: continue
                    interp_map = {'pchip': PchipInterpolator, 'akima': Akima1DInterpolator}
                    Interpolator = interp_map.get(method, interp1d)

                    if method in interp_map:
                        f = Interpolator(dfu[time_col], dfu[col])
                    else: # linear, cubic
                        f = Interpolator(dfu[time_col], dfu[col], kind=method, bounds_error=False, fill_value="extrapolate")

                    new_data[col] = f(new_time)

                df_filtered = pd.DataFrame(new_data).dropna().reset_index(drop=True)
                exibir_mensagem(f"Interpolação '{method}' aplicada, gerando {len(df_filtered)} pontos.")

            else:
                exibir_erro("Método de filtro desconhecido."); return

            self.dfs_ensaios[idx] = df_filtered
            self.history.push(df_filtered, f"M3:Filtro:{method}:{idx}")
            self._update_slider_range(idx, slider)

        except Exception as e:
            exibir_erro(f"Erro ao aplicar filtro: {e}")

    def _on_plot(self, idx, fig_out, log_out):
        with log_out: clear_output(wait=True)
        with fig_out: clear_output(wait=True)
        dfi = self.dfs_ensaios[idx]
        if dfi.empty:
            with log_out: exibir_erro("DataFrame vazio. Nada para plotar."); return

        time_col = next((c for c in dfi.columns if c.startswith('Time_s')), None)
        temp_col = next((c for c in dfi.columns if c.startswith('Temperature_C')), None)
        dens_col = next((c for c in dfi.columns if c.startswith('DensidadePct')), None)

        if not (time_col and temp_col and dens_col):
            with log_out: exibir_erro("Faltam colunas essenciais para plotar."); return

        with fig_out:
            fig, axs = plt.subplots(1, 3, figsize=(15, 4), tight_layout=True)
            fig.suptitle(f"Ensaio {idx+1} - Visualização de Dados Atuais")
            axs[0].plot(dfi[time_col], dfi[dens_col], '.-')
            axs[0].set(xlabel="Tempo (s)", ylabel="Densidade (%)")
            axs[1].plot(dfi[temp_col], dfi[dens_col], 'r.-')
            axs[1].set(xlabel="Temperatura (°C)", ylabel="Densidade (%)")
            axs[2].plot(dfi[time_col], dfi[temp_col], 'g.-')
            axs[2].set(xlabel="Tempo (s)", ylabel="Temperatura (°C)")
            for ax in axs: ax.grid(True, alpha=0.5)
            plt.show()

    def _on_export(self, idx, log_out):
        with log_out: clear_output(wait=True)
        dfi = self.dfs_ensaios[idx]
        if dfi.empty: exibir_erro("Nada para exportar."); return
        link = gerar_link_download(dfi, nome_arquivo=f"Ensaio_{idx+1}_Filtrado.xlsx")
        display(link)

    def display(self):
        display(self.main_ui)

    def get_dfs(self):
        return self.dfs_ensaios

# --- LINHA ESSENCIAL PARA O FUNCIONAMENTO EM NOTEBOOK ---
# Registra o conteúdo desta célula como um módulo importável.
sys.modules['modulo3_filtrorecorte'] = sys.modules[__name__]

# MÓDULO Roteador 1 - Arhenius ou LogTheta
# modulo_roteadormetodo.py
# Exemplo de Módulo final do seu notebook

import ipywidgets as widgets
from IPython.display import display, clear_output

# Texto de apresentação - somente será exibido agora
intro_text = """
<div style="font-family: Arial, sans-serif; line-height: 1.5;">
    <h2>Final Steps - Ogum Sintering</h2>
    <p>
        Obrigado por utilizar o Ogum Sintering até aqui.
        Agora você pode escolher entre os métodos finais
        para realizar a análise de dados. O Cálculo de LogTheta,
        de acordo com os trabalhos de Su e Johnson para Curvas mestras
        ou a Confecção de Curvas de Arhhenius:
    </p>
</div>
"""

# RadioButtons para escolha do método
method_radio = widgets.RadioButtons(
    options=["LogTheta ( Curvas Mestras )", "Curvas de Arrhenius "],
    value="LogTheta ( Curvas Mestras )",
    description="Method:",
    style={'description_width': 'initial'}
)


# Botão para prosseguir
proceed_button = widgets.Button(description="Realizar Ação", button_style='success')

# Área de saída para logs
out = widgets.Output()

def on_proceed_clicked(b):
    with out:
        clear_output()
        choice = method_radio.value
        if choice == "LogTheta ( Curvas Mestras )":
            print("[INFO] User chose LogTheta method.")
            # Chame aqui o(s) módulo(s) correspondentes ao LogTheta
            # Por exemplo: iniciar_modulo_logtheta()
        else:
            print("[INFO] User chose Arrhenius method.")
            # Chame aqui o(s) módulo(s) correspondentes ao Arrhenius
            # Por exemplo: iniciar_modulo_arrhenius()
    # Opcional: Oculta a interface de escolha após prosseguir
    ui.layout.display = 'none'


proceed_button.on_click(on_proceed_clicked)

# Monta a interface final
ui = widgets.VBox([
    widgets.HTML(value=intro_text),
    method_radio,
    proceed_button,
    out
])

# MÓDULO 4 - Cálculo de LogTheta
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import List
from collections import defaultdict
import sys

# Importando do seu arquivo core
from core import (
    SinteringDataRecord, EaSelectionWidget, exibir_mensagem, exibir_erro,
    gerar_link_download, R, cumtrapz
)

class ModuloLogTheta:
    """
    Calcula o log(theta).
    Plota os gráficos em um widget de saída fornecido pelo controlador
    para manter um layout de UI consistente.
    """
    def __init__(self, dfs_ensaios: List[pd.DataFrame], fig_out: widgets.Output):
        self.dfs_ensaios = [df for df in dfs_ensaios if df is not None and not df.empty]
        self.sintering_records: List[SinteringDataRecord] = []

        self.ea_selector = EaSelectionWidget()
        self.out = widgets.Output()      # Saída para mensagens de texto
        # Use an Output widget specifically for plotting
        self._fig_output = widgets.Output()
        self.fig_out_container = fig_out # This is the VBox container provided by the controller
        self.fig_out_container.children = [self._fig_output] # Place the Output widget inside the VBox

        self._build_ui()

    def _build_ui(self):
        self.btn_calc_logtheta = widgets.Button(description="Calcular LogTheta", button_style='success', icon='calculator')
        self.btn_plot_curves = widgets.Button(description="Visualizar Curvas", button_style='warning', icon='line-chart', disabled=True)
        self.btn_export_logtheta = widgets.Button(description="Exportar Resultados", button_style='info', icon='download', disabled=True)

        self.btn_calc_logtheta.on_click(self._on_calc_logtheta)
        self.btn_plot_curves.on_click(self._on_plot_curves)
        self.btn_export_logtheta.on_click(self._on_export_logtheta)

        self.ui = widgets.VBox([
            widgets.HTML("<h3>Módulo 4: Cálculo de LogTheta</h3>"),
            self.ea_selector.ui,
            widgets.HBox([self.btn_calc_logtheta, self.btn_plot_curves, self.btn_export_logtheta]),
            self.out
        ])

    def _on_calc_logtheta(self, b):
        with self.out: clear_output(wait=True)
        # Clear the dedicated Output widget for figures
        with self._fig_output: clear_output(wait=True)

        self.sintering_records = []
        eas = self.ea_selector.get_ea_list()
        if not eas: return

        with self.out: exibir_mensagem(f"Iniciando cálculo para {len(eas)} energias de ativação...")

        for i, df_ensaio in enumerate(self.dfs_ensaios):
            time_col = next((c for c in df_ensaio.columns if c.startswith('Time_s')), None)
            temp_col = next((c for c in df_ensaio.columns if c.startswith('Temperature_C')), None)
            dens_col = next((c for c in df_ensaio.columns if c.startswith('DensidadePct')), None)

            if not (time_col and temp_col and dens_col):
                with self.out: exibir_erro(f"Ensaio {i+1}: Colunas essenciais não encontradas. Pulando."); continue
            if df_ensaio[time_col].size < 2:
                with self.out: exibir_erro(f"Ensaio {i+1}: Dados insuficientes para integração. Pulando."); continue

            T_k = df_ensaio[temp_col].values + 273.15

            for Ea_kj in eas:
                try:
                    Ea_j = Ea_kj * 1000.0
                    theta_inst = (1.0 / T_k) * np.exp(-Ea_j / (R * T_k))
                    integrated = cumtrapz(theta_inst, df_ensaio[time_col].values, initial=0)

                    with np.errstate(divide='ignore', invalid='ignore'):
                        log_integrated = np.log10(integrated)
                    log_integrated[~np.isfinite(log_integrated)] = np.nan

                    df_record = pd.DataFrame({
                        'logtheta': log_integrated,
                        'valor': df_ensaio[dens_col].values,
                        'tempo_s': df_ensaio[time_col].values
                    })
                    record = SinteringDataRecord(i, Ea_kj, 'densidade_original', df_record)
                    self.sintering_records.append(record)
                except Exception as e:
                    with self.out: exibir_erro(f"Ensaio {i+1}: Falha ao calcular para Ea={Ea_kj:.2f}. Erro: {e}")

        # Habilita os botões após o cálculo
        self.btn_plot_curves.disabled = not self.sintering_records
        self.btn_export_logtheta.disabled = not self.sintering_records
        with self.out:
            exibir_mensagem(f"Cálculo concluído. {len(self.sintering_records)} registros gerados.")

    def _on_plot_curves(self, b):
        with self.out: clear_output(wait=True)
        # Clear the dedicated Output widget for figures
        with self._fig_output: clear_output(wait=True)

        if not self.sintering_records:
            with self.out: exibir_erro("Nenhum dado para plotar."); return

        records_por_ensaio = defaultdict(list)
        for rec in self.sintering_records:
            records_por_ensaio[rec.ensaio_id].append(rec)

        with self._fig_output: # Plot within the dedicated Output widget
            for ensaio_id, records in sorted(records_por_ensaio.items()):
                fig, ax = plt.subplots(figsize=(8, 6))
                ax.set_title(f"Ensaio {ensaio_id + 1} – Densidade vs. LogTheta")
                ax.set_xlabel("log(theta)")
                ax.set_ylabel("Densidade (%)")

                for rec in records:
                    df_plot = rec.df.dropna(subset=['logtheta', 'valor'])
                    if len(df_plot) < 2: continue
                    label = f"Ea={rec.Ea:.2f} kJ/mol"
                    ax.plot(df_plot['logtheta'], df_plot['valor'], 'o-', ms=3, label=label)

                ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
                ax.grid(True)
                plt.tight_layout()
                plt.show()

        with self.out:
            exibir_mensagem("Gráficos gerados na área de visualização.")

    def _on_export_logtheta(self, b):
        with self.out: clear_output(wait=True)
        if not self.sintering_records:
            exibir_erro("Nenhum dado disponível para exportação."); return

        all_dfs = []
        for rec in self.sintering_records:
            nome = f"E{rec.ensaio_id+1}_Ea{rec.Ea:.2f}"
            df_sub = rec.df[['logtheta', 'valor']].copy()
            df_sub.columns = [f"logtheta_{nome}", f"densidade_{nome}"]
            all_dfs.append(df_sub)

        df_export = pd.concat(all_dfs, axis=1)
        link = gerar_link_download(df_export, nome_arquivo="Resultados_LogTheta_Largo.xlsx")
        with self.out:
            display(link)
            exibir_mensagem("Exportação concluída.")

    def get_sintering_records(self) -> List[SinteringDataRecord]:
        return self.sintering_records

# --- LINHA ESSENCIAL PARA O FUNCIONAMENTO EM NOTEBOOK ---
sys.modules['modulo4_logtheta'] = sys.modules[__name__]

import ipywidgets as widgets
from IPython.display import display, clear_output
import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from typing import List

# Importando do seu arquivo core
from core import SinteringDataRecord, exibir_mensagem, exibir_erro, gerar_link_download

class Modulo5_1Alinhamento:
    """
    Módulo para alinhar curvas de sinterização. Agora com funcionalidade de exportação.
    """
    def __init__(self, sintering_records: List[SinteringDataRecord]):
        self.input_records = [rec for rec in sintering_records if rec.tipo_dado_y == 'densidade_original']
        self.all_input_records = sintering_records
        self.aligned_records: List[SinteringDataRecord] = []
        self.out = widgets.Output()
        self._build_ui()

    def _build_ui(self):
        if not self.input_records:
            self.main_ui = widgets.HTML("<b>Nenhum dado de 'densidade_original' disponível para alinhamento.</b>")
            return

        self.radio_axis = widgets.RadioButtons(
            options=[("Eixo comum de log(θ)", "logtheta"), ("Eixo comum de Densidade", "dens")],
            value="dens", description="Alinhar por:"
        )
        self.int_n_points = widgets.IntText(value=200, description="Nº de Pontos:")
        self.btn_apply = widgets.Button(description="Aplicar Alinhamento", button_style='success', icon='cogs')

        # Novo botão de exportação
        self.btn_export = widgets.Button(description="Exportar Dados Alinhados", button_style='info', icon='download', disabled=True)

        self.btn_apply.on_click(self._on_apply_alignment)
        self.btn_export.on_click(self._on_export)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.1 – Alinhamento e Interpolação</h3>"),
            widgets.HTML("<p>Selecione o eixo para criar uma grade comum. As curvas serão reamostradas nesta grade.</p>"),
            self.radio_axis, self.int_n_points,
            widgets.HBox([self.btn_apply, self.btn_export]),
            self.out
        ])

    def _on_apply_alignment(self, b):
        with self.out: clear_output(wait=True)
        exibir_mensagem("Iniciando processo de alinhamento...")

        self.aligned_records = []
        mode = self.radio_axis.value
        n_points = self.int_n_points.value
        if n_points < 2:
            exibir_erro("Número de pontos deve ser no mínimo 2."); return

        # --- Lógica de alinhamento implementada ---
        all_logtheta = np.concatenate([rec.df['logtheta'].dropna().values for rec in self.input_records])
        all_valores = np.concatenate([rec.df['valor'].dropna().values for rec in self.input_records])

        if all_logtheta.size == 0 or all_valores.size == 0:
            exibir_erro("Dados insuficientes em todos os records para alinhamento.")
            return

        if mode == "dens":
            # Alinhar por Densidade (Y)
            common_axis = np.linspace(np.min(all_valores), np.max(all_valores), n_points)
            x_col_name = 'logtheta'
            y_col_name = 'valor'
            aligned_x_name = 'logtheta_alinhado'
            aligned_y_name = 'densidade_alinhada'

        else: # mode == "logtheta"
            # Alinhar por log(theta) (X)
            common_axis = np.linspace(np.min(all_logtheta), np.max(all_logtheta), n_points)
            x_col_name = 'logtheta'
            y_col_name = 'valor'
            aligned_x_name = 'logtheta_alinhado'
            aligned_y_name = 'densidade_alinhada' # Note: Still density, just interpolated on logtheta axis

        for rec in self.input_records:
            df_clean = rec.df.dropna(subset=[x_col_name, y_col_name]).sort_values(x_col_name).copy()
            if len(df_clean) < 2: continue

            # Interpolação
            try:
                if mode == "dens":
                    # Interpolar logtheta em função de valor (densidade)
                    f_interp = interp1d(df_clean[y_col_name], df_clean[x_col_name], kind='linear', bounds_error=False, fill_value=np.nan)
                    aligned_x_vals = f_interp(common_axis)
                    aligned_y_vals = common_axis # Common axis is density

                else: # mode == "logtheta"
                    # Interpolar valor (densidade) em função de logtheta
                    f_interp = interp1d(df_clean[x_col_name], df_clean[y_col_name], kind='linear', bounds_error=False, fill_value=np.nan)
                    aligned_x_vals = common_axis # Common axis is logtheta
                    aligned_y_vals = f_interp(common_axis)

                # Incluir a coluna tempo_s_alinhado interpolada
                # Assumindo que 'tempo_s' existe nos records originais
                time_col = next((c for c in df_clean.columns if 'tempo_s' in c), None)
                aligned_time_vals = np.full_like(common_axis, np.nan, dtype=float) # Initialize with NaN

                if time_col:
                    # Decide which axis to use for time interpolation based on the alignment mode
                    if mode == "dens":
                         # If aligning by density, interpolate time vs density
                         f_time_interp = interp1d(df_clean[y_col_name], df_clean[time_col], kind='linear', bounds_error=False, fill_value=np.nan)
                         aligned_time_vals = f_time_interp(common_axis)
                    else: # mode == "logtheta"
                         # If aligning by logtheta, interpolate time vs logtheta
                         f_time_interp = interp1d(df_clean[x_col_name], df_clean[time_col], kind='linear', bounds_error=False, fill_value=np.nan)
                         aligned_time_vals = f_time_interp(common_axis)


                df_aligned = pd.DataFrame({
                    aligned_x_name: aligned_x_vals,
                    aligned_y_name: aligned_y_vals,
                    'tempo_s_alinhado': aligned_time_vals # Include interpolated time
                }).dropna() # Drop rows with NaN values from interpolation

                if not df_aligned.empty:
                    aligned_rec = SinteringDataRecord(
                        ensaio_id=rec.ensaio_id,
                        Ea=rec.Ea, # Ea from original record
                        tipo_dado_y='dados_alinhados', # New type
                        df=df_aligned,
                        metadata=rec.metadata.copy() # Keep original metadata
                    )
                    self.aligned_records.append(aligned_rec)

            except Exception as e:
                exibir_erro(f"Erro na interpolação para Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}: {e}")

        # --- Fim da lógica de alinhamento ---

        exibir_mensagem(f"Alinhamento concluído. {len(self.aligned_records)} registros 'alinhados' gerados.")
        # Habilita o botão de exportar após o cálculo
        self.btn_export.disabled = not self.aligned_records

    def _on_export(self, b):
        with self.out: clear_output(wait=True)
        if not self.aligned_records:
            exibir_erro("Nenhum dado alinhado para exportar. Aplique o alinhamento primeiro."); return

        all_dfs = []
        for rec in self.aligned_records:
            df_copy = rec.df.copy()
            # Renomeia colunas para serem únicas no arquivo final
            rename_map = {
                col: f"{col}_E{rec.ensaio_id+1}_Ea{rec.Ea:.1f}"
                for col in df_copy.columns
            }
            df_copy.rename(columns=rename_map, inplace=True)
            all_dfs.append(df_copy)

        df_export = pd.concat(all_dfs, axis=1)
        link = gerar_link_download(df_export, nome_arquivo="Dados_Alinhados.xlsx")
        display(link)
        exibir_mensagem("Arquivo com dados alinhados gerado.")

    def display(self):
        display(self.main_ui)

    def get_aligned_records(self) -> List[SinteringDataRecord]:
        return self.all_input_records + self.aligned_records

import sys
sys.modules['modulo5_1_alinhamento'] = sys.modules[__name__]

# MÓDULO 5_2_Parâmetros de Densificação
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import List
from io import BytesIO
import sys

# Importando do seu arquivo core
from core import (
    SinteringDataRecord, exibir_mensagem, exibir_erro, gerar_link_download, DataHistory
)

class Modulo5_2BlaineParameters:
    """
    Calcula os parâmetros de densificação (Psi e Phi).
    Plota os gráficos em um widget de saída fornecido pelo controlador
    e permite a exportação dos dados gerados.
    """
    def __init__(self, sintering_records: List[SinteringDataRecord], fig_out: widgets.Output):
        self.input_records = sintering_records
        self.records_to_process = [rec for rec in sintering_records if rec.tipo_dado_y == 'dados_alinhados']
        self.processed_records: List[SinteringDataRecord] = []
        self.history = DataHistory()
        self.out = widgets.Output() # Saída para logs e mensagens
        # Use an Output widget specifically for plotting
        self._fig_output = widgets.Output()
        self.fig_out_container = fig_out # This is the VBox container provided by the controller
        self.fig_out_container.children = [self._fig_output] # Place the Output widget inside the VBox
        self._build_ui()

    def _build_ui(self):
        if not self.records_to_process:
            self.main_ui = widgets.HTML("<b>Nenhum dado do tipo 'dados_alinhados' encontrado para processar.</b>")
            return

        self.float_rho0 = widgets.FloatText(value=55.0, description="ρ0 (Dens. Inicial %):")
        self.btn_calc = widgets.Button(description="Calcular Psi e Phi", button_style='success', icon='calculator')
        self.btn_plot = widgets.Button(description="Visualizar Curvas", button_style='warning', icon='line-chart')
        self.btn_export = widgets.Button(description="Exportar Psi e Phi", button_style='info', icon='download', disabled=True)

        self.btn_calc.on_click(self._on_calc_blaine)
        self.btn_plot.on_click(self._on_plot)
        self.btn_export.on_click(self._on_export)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.2 – Parâmetros de Densificação</h3>"),
            self.float_rho0,
            widgets.HBox([self.btn_calc, self.btn_plot, self.btn_export]),
            self.out # Apenas a saída de logs é mostrada aqui
        ])

    def _on_calc_blaine(self, b):
        with self.out: clear_output(wait=True)
        exibir_mensagem("Iniciando cálculo dos parâmetros de densificação...")

        rho0 = self.float_rho0.value
        if not (0 < rho0 < 100):
            exibir_erro("O valor de ρ0 (Densidade Inicial) deve estar entre 0 e 100."); return

        self.processed_records = []
        for rec in self.records_to_process:
            try:
                df_input = rec.df
                required = ['densidade_alinhada', 'logtheta_alinhado', 'tempo_s_alinhado']
                if not all(col in df_input.columns for col in required):
                    exibir_erro(f"Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}: Faltam colunas alinhadas. Pulando."); continue

                dens = df_input['densidade_alinhada'].values
                logtheta = df_input['logtheta_alinhado'].values
                tempo = df_input['tempo_s_alinhado'].values

                # ----- Cálculo de Psi -----
                psi_vals = (dens - rho0) / (100.0 - rho0)
                df_psi = pd.DataFrame({'logtheta': logtheta, 'valor': psi_vals, 'tempo_s_alinhado': tempo})
                self.processed_records.append(
                    SinteringDataRecord(rec.ensaio_id, rec.Ea, 'psi', df_psi, rec.metadata.copy())
                )

                # ----- Cálculo de Phi -----
                phi_vals = (dens - rho0) / (100.0 - dens + 1e-9)
                df_phi = pd.DataFrame({'logtheta': logtheta, 'valor': phi_vals, 'tempo_s_alinhado': tempo})
                self.processed_records.append(
                    SinteringDataRecord(rec.ensaio_id, rec.Ea, 'phi', df_phi, rec.metadata.copy())
                )
            except Exception as e:
                exibir_erro(f"Erro ao calcular Blaine para Ea={rec.Ea}: {e}")

        with self.out:
            exibir_mensagem(f"Cálculo concluído. {len(self.processed_records)} novos records ('psi' e 'phi') foram gerados.")
        self.btn_export.disabled = not self.processed_records

    def _on_plot(self, b):
        with self.out: clear_output(wait=True)
        with self._fig_output: clear_output(wait=True)

        if not self.processed_records:
            with self.out: exibir_erro("Nenhum parâmetro calculado para plotar."); return

        with self._fig_output:
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5), sharey=False, tight_layout=True)
            fig.suptitle("Parâmetros de Densificação vs. log(θ)")

            ax1.set(title="Parâmetro ψ (Psi)", xlabel="log(theta)", ylabel="ψ = (ρ-ρ₀)/(100-ρ₀)")
            ax2.set(title="Parâmetro φ (Phi)", xlabel="log(theta)", ylabel="φ = (ρ-ρ₀)/(100-ρ)")

            for rec in self.processed_records:
                dfp = rec.df.dropna()
                if dfp.empty: continue
                label = f"E{rec.ensaio_id+1} Ea={rec.Ea:.1f}"
                if rec.tipo_dado_y == 'psi':
                    ax1.plot(dfp['logtheta'], dfp['valor'], 'o-', ms=3, label=label)
                elif rec.tipo_dado_y == 'phi':
                    ax2.plot(dfp['logtheta'], dfp['valor'], 'o-', ms=3, label=label)

            ax1.grid(True); ax1.legend()
            ax2.grid(True); ax2.legend()
            plt.show()

        with self.out:
            exibir_mensagem("Gráficos gerados na área de visualização.")

    def _on_export(self, b):
        with self.out: clear_output(wait=True)
        if not self.processed_records:
            exibir_erro("Nenhum dado processado para exportar."); return

        psi_dfs, phi_dfs = [], []
        for rec in self.processed_records:
            df_copy = rec.df[['logtheta', 'valor']].copy()
            base_name = f"E{rec.ensaio_id+1}_Ea{rec.Ea:.1f}"

            if rec.tipo_dado_y == 'psi':
                df_copy.rename(columns={'logtheta': f'logtheta_{base_name}', 'valor': f'psi_{base_name}'}, inplace=True)
                psi_dfs.append(df_copy)
            elif rec.tipo_dado_y == 'phi':
                df_copy.rename(columns={'logtheta': f'logtheta_{base_name}', 'valor': f'phi_{base_name}'}, inplace=True)
                phi_dfs.append(df_copy)

        df_psi = pd.concat(psi_dfs, axis=1)
        df_phi = pd.concat(phi_dfs, axis=1)

        link_psi = gerar_link_download(df_psi, "Dados_Psi.xlsx")
        link_phi = gerar_link_download(df_phi, "Dados_Phi.xlsx")

        display(HTML("<b>Links para Download:</b>"))
        display(link_psi)
        display(link_phi)

    def display(self):
        display(self.main_ui)

    def get_blaine_records(self) -> List[SinteringDataRecord]:
        return self.input_records + self.processed_records

# Registra o conteúdo desta célula como um módulo importável

sys.modules['modulo5_2_blaine'] = sys.modules[__name__]

# MÓDULO 5_3_Fitting Sigmoidal
import ipywidgets as widgets
from IPython.display import display
import numpy as np
import pandas as pd
from typing import List, Dict

# Importações do core/modulo1
from core import (
    SinteringDataRecord, exibir_mensagem, exibir_erro,
    boltzmann_sigmoid, generalized_logistic_stable
)
from scipy.optimize import curve_fit

class Modulo5_3Sigmoides:
    """
    Submódulo 5.3 – Ajuste Sigmoidal.
    Apresenta uma UI para o usuário selecionar quais dados processados (ex: psi, phi)
    devem ser usados para o ajuste com os modelos sigmodais.
    """
    def __init__(self, sintering_records: List[SinteringDataRecord]):
        self.input_records = sintering_records
        self.processed_records: List[SinteringDataRecord] = []
        self._build_ui()

    def _build_ui(self):
        # Mapeia nomes internos para nomes amigáveis na UI
        self.DATA_OPTIONS_MAP = {
            "Dados Alinhados": "dados_alinhados",
            "Parâmetro Psi (ψ)": "psi",
            "Parâmetro Phi (φ)": "phi",
            "Densidade Original": "densidade_original", # Added this option
        }

        # Filtra opções para mostrar apenas os tipos de dados que realmente existem
        available_types = set(rec.tipo_dado_y for rec in self.input_records)
        available_options = [ui_text for ui_text, internal in self.DATA_OPTIONS_MAP.items() if internal in available_types]

        if not available_options:
            self.main_ui = widgets.HTML("<b>Nenhum dado compatível (alinhado, psi, phi, ou original) encontrado para ajuste.</b>")
            return

        self.select_data = widgets.SelectMultiple(
            options=available_options,
            value=[available_options[0]] if available_options else [], # Seleciona o primeiro por padrão
            description="Ajustar curvas de:",
            rows=len(available_options),
            style={'description_width': 'initial'},
            disabled=False
        )

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Módulo 5.3 – Seleção para Ajuste Sigmoidal</h3>"),
            widgets.HTML("<p>Selecione um ou mais conjuntos de dados para realizar o ajuste com as funções de Boltzmann (4 parâmetros) e Logística Generalizada (5 parâmetros).</p>"),
            self.select_data
        ])

    def display(self):
        display(self.main_ui)

    def run_all_fits(self, data_types_to_fit: List[str], p0_overrides: Dict = None):
        """Executa ambos os ajustes para os tipos de dados informados."""
        exibir_mensagem(f"Iniciando ajuste duplo para: {data_types_to_fit}")
        self.processed_records = []

        records_to_process = [rec for rec in self.input_records if rec.tipo_dado_y in data_types_to_fit]
        if not records_to_process:
            exibir_erro("Nenhum record correspondente à seleção foi encontrado para ajuste."); return

        for rec in records_to_process:
            # ... (o resto da lógica de `run_all_fits` que você já tinha)
            # A lógica interna de ajuste já estava boa, o problema era a falta da UI para a seleção.
            df_clean = rec.df.dropna()
            if len(df_clean) < 5: continue

            x_col = next((c for c in df_clean.columns if 'logtheta' in c), None)
            y_col = next((c for c in df_clean.columns if c != x_col and 'tempo' not in c), None)
            if not x_col or not y_col: continue

            x_data, y_data = df_clean[x_col].values, df_clean[y_col].values

            # Ajuste Boltzmann
            try:
                p0b_manual = p0_overrides.get((rec.ensaio_id, rec.Ea, rec.tipo_dado_y), {}).get('boltzmann') if p0_overrides else None
                p0b = p0b_manual or [y_data.max(), y_data.min(), np.median(x_data), (x_data.max()-x_data.min())/4]
                popt, pcov = curve_fit(boltzmann_sigmoid, x_data, y_data, p0=p0b, maxfev=10000)
                std_err = np.sqrt(np.diag(pcov))
                df_fit = pd.DataFrame({'logtheta_fit': x_data, 'valor_ajustado': boltzmann_sigmoid(x_data, *popt)})
                self.processed_records.append(SinteringDataRecord(
                    rec.ensaio_id, rec.Ea, f"fit_boltzmann_{rec.tipo_dado_y}", df_fit,
                    {'model_name': 'boltzmann', 'popt': popt.tolist(), 'std_errors': std_err.tolist(), 'param_names': ['A1','A2','x0','dx'], 'source_type': rec.tipo_dado_y}
                ))
            except Exception as e:
                exibir_erro(f"Boltzmann falhou para {rec.tipo_dado_y} (Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}): {e}")

            # Ajuste Logístico
            try:
                p0l_manual = p0_overrides.get((rec.ensaio_id, rec.Ea, rec.tipo_dado_y), {}).get('logistic') if p0_overrides else None
                p0l = p0l_manual or [y_data.max(), y_data.min(), np.median(x_data), (x_data.max()-x_data.min())/4, 1.0]
                popt, pcov = curve_fit(generalized_logistic_stable, x_data, y_data, p0=p0l, maxfev=10000)
                std_err = np.sqrt(np.diag(pcov))
                df_fit = pd.DataFrame({'logtheta_fit': x_data, 'valor_ajustado': generalized_logistic_stable(x_data, *popt)})
                self.processed_records.append(SinteringDataRecord(
                    rec.ensaio_id, rec.Ea, f"fit_logistic_{rec.tipo_dado_y}", df_fit,
                    {'model_name': 'logistic', 'popt': popt.tolist(), 'std_errors': std_err.tolist(), 'param_names': ['A1','A2','x0','b','c'], 'source_type': rec.tipo_dado_y}
                ))
            except Exception as e:
                exibir_erro(f"Logístico falhou para {rec.tipo_dado_y} (Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}): {e}")

    def get_all_records_after_fit(self) -> List[SinteringDataRecord]:
        return self.input_records + self.processed_records
import sys
sys.modules['modulo5_3_sigmoides'] = sys.modules[__name__]

# Modulo 5_3_1 Revisao
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from typing import List, Dict, Any
from collections import defaultdict
import sys

# Importando do seu arquivo core
from core import SinteringDataRecord, exibir_mensagem, exibir_erro, gerar_link_download

class Modulo5_3_1_Revisao:
    """
    Módulo de Revisão dos Ajustes.
    Exibe o tempo equivalente para o ponto de inflexão ajustado e experimental,
    e permite a exportação da tabela de resumo.
    """
    def __init__(self, all_records: List[SinteringDataRecord], controller=None):
        self.all_records = all_records
        self.controller = controller

        self.fit_records = [rec for rec in self.all_records if rec.tipo_dado_y.startswith('fit_')]
        # Consider only source records that are expected to have 'logtheta' and 'valor'
        self.source_records = {
            (rec.ensaio_id, rec.Ea, rec.tipo_dado_y): rec
            for rec in self.all_records
            if not rec.tipo_dado_y.startswith('fit_') and
               'logtheta' in rec.df.columns and 'valor' in rec.df.columns and
               any('tempo' in col for col in rec.df.columns) # Check for time column existence
        }

        self.manual_widgets: Dict[tuple, Dict[str, Dict[str, widgets.FloatText]]] = {}
        self.summary_df: pd.DataFrame = pd.DataFrame() # Para armazenar a tabela de resumo
        self.out = widgets.Output()

        self._build_ui()
        self._update_summary_table()

    def _build_ui(self):
        self.summary_container = widgets.VBox([])

        self.btn_confirm = widgets.Button(description="Confirmar e Prosseguir", button_style='success', icon='check')
        self.btn_manual_toggle = widgets.Button(description="Editar Parâmetros (p0)", button_style='info', icon='edit')
        self.btn_export = widgets.Button(description="Exportar Resumo", button_style='info', icon='download', disabled=True)

        self.manual_adjust_container = widgets.VBox(layout={'display': 'none'})

        self.btn_confirm.on_click(self._on_confirm_and_proceed)
        self.btn_manual_toggle.on_click(self._on_toggle_manual_adjust)
        self.btn_export.on_click(self._on_export)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.3.1 – Revisão e Validação dos Ajustes</h3>"),
            widgets.HTML("<p>A tabela abaixo compara os parâmetros dos ajustes com os pontos de inflexão experimentais, incluindo o tempo equivalente em segundos.</p>"),
            self.summary_container,
            widgets.HBox([self.btn_manual_toggle, self.btn_export, self.btn_confirm]),
            self.manual_adjust_container,
            self.out
        ])

    def display(self):
        display(self.main_ui)

    def _calculate_experimental_inflexion(self) -> Dict[tuple, Dict[str, float]]:
        """Calcula log(theta) e o tempo no ponto de inflexão experimental."""
        exp_inflexion_points: Dict[tuple, Dict[str, float]] = {}

        for key, rec in self.source_records.items():
            df = rec.df.dropna().copy()
            time_col = next((c for c in df.columns if 'tempo' in c), None)

            # Add checks for required columns
            if 'valor' not in df.columns or 'logtheta' not in df.columns or not time_col or len(df) < 3:
                continue

            # Ensure logtheta is sorted for gradient calculation
            df = df.sort_values('logtheta').reset_index(drop=True)

            # Calculate the rate of change (derivative)
            # Add check to prevent division by zero or near-zero values in logtheta
            logtheta_diff = np.diff(df['logtheta'])
            if np.any(np.abs(logtheta_diff) < 1e-9): # Check if there are very small steps
                 # Handle cases where logtheta is not strictly increasing or has duplicate values
                 df_unique_logtheta = df.drop_duplicates(subset=['logtheta']).sort_values('logtheta')
                 if len(df_unique_logtheta) < 2: continue # Need at least 2 unique points
                 try:
                     # Use interpolation to get values on a strictly increasing logtheta axis
                     f_valor = interp1d(df_unique_logtheta['logtheta'], df_unique_logtheta['valor'], kind='linear', bounds_error=False, fill_value=np.nan)
                     f_time = interp1d(df_unique_logtheta['logtheta'], df_unique_logtheta[time_col], kind='linear', bounds_error=False, fill_value=np.nan)

                     # Create a new dataframe with unique, sorted logtheta values for gradient calculation
                     new_logtheta = df_unique_logtheta['logtheta'].values
                     new_valor = f_valor(new_logtheta)
                     new_time = f_time(new_logtheta)

                     df_processed = pd.DataFrame({'logtheta': new_logtheta, 'valor': new_valor, time_col: new_time}).dropna()

                     if len(df_processed) < 3: continue # Need at least 3 points for gradient
                     taxa = np.gradient(df_processed['valor'], df_processed['logtheta'])
                     df_for_inflexion = df_processed # Use processed dataframe for inflexion
                 except Exception:
                     continue # Skip if interpolation/processing fails
            else:
                 taxa = np.gradient(df['valor'], df['logtheta'])
                 df_for_inflexion = df # Use original dataframe if logtheta is fine

            if len(taxa) > 0:
                idx_pico = int(np.argmax(taxa))
                exp_inflexion_points[key] = {
                    'logtheta_exp': float(df_for_inflexion['logtheta'].iloc[idx_pico]),
                    'tempo_s_exp': float(df_for_inflexion[time_col].iloc[idx_pico])
                }
        return exp_inflexion_points

    def _update_summary_table(self):
        """Calcula os parâmetros e os tempos equivalentes e exibe na tabela."""
        with self.out: clear_output(wait=True)

        if not self.fit_records:
            self.summary_container.children = [widgets.HTML("<p style='color:red;'>Nenhum resultado de ajuste encontrado.</p>")]
            return

        exp_inflexion = self._calculate_experimental_inflexion()

        summary_data = []
        for rec in self.fit_records:
            source_type = rec.metadata.get('source_type')
            if not source_type: continue

            # Ensure the corresponding source record exists and has necessary columns
            key = (rec.ensaio_id, rec.Ea, source_type)
            source_rec = self.source_records.get(key)
            if source_rec is None or 'logtheta' not in source_rec.df.columns or 'valor' not in source_rec.df.columns:
                continue # Skip if the source record or its columns are missing

            exp_vals = exp_inflexion.get(key, {'logtheta_exp': np.nan, 'tempo_s_exp': np.nan})
            # Access the correct x0 based on model and param names
            model_name = rec.metadata.get('model_name', 'N/A')
            param_names = rec.metadata.get('param_names', [])
            popt = rec.metadata.get('popt', [])

            x0_fit = np.nan
            if 'x0' in param_names:
                try:
                    x0_fit = popt[param_names.index('x0')]
                except IndexError:
                    pass # x0 not found in popt

            # Lógica para encontrar o tempo equivalente do ajuste
            tempo_equivalente_fit = np.nan

            if source_rec and not source_rec.df.empty and pd.notna(x0_fit):
                source_df = source_rec.df.dropna().sort_values('logtheta')
                time_col = next((c for c in source_df.columns if 'tempo' in c), None)
                # Ensure time_col exists and there are enough unique logtheta points for interpolation
                if time_col and source_df['logtheta'].nunique() > 1:
                    try:
                        f_time = interp1d(
                            source_df['logtheta'], source_df[time_col],
                            kind='linear', bounds_error=False, fill_value=np.nan
                        )
                        tempo_equivalente_fit = float(f_time(x0_fit))
                    except Exception:
                        pass # Mantém NaN se a interpolação falhar

            row = {
                'Modelo': model_name,
                'Dado Origem': source_type,
                'x0 (Ajuste)': x0_fit,
                'x0 (Experimental)': exp_vals['logtheta_exp'],
                'Tempo Inflexão (Ajuste)': tempo_equivalente_fit,
                'Tempo Inflexão (Experimental)': exp_vals['tempo_s_exp']
            }
            summary_data.append(row)

        self.summary_df = pd.DataFrame(summary_data)

        if self.summary_df.empty:
             self.summary_container.children = [widgets.HTML("<p style='color:orange;'>Nenhum resultado de ajuste válido para resumir.</p>")]
             self.btn_export.disabled = True
             return

        # Calculate mean only if there are valid rows after filtering
        df_avg = self.summary_df.groupby(['Modelo', 'Dado Origem']).mean(numeric_only=True).reset_index()

        html_table = df_avg.to_html(index=False, float_format='{:.2f}'.format, border=0, classes='table table-striped')
        self.summary_container.children = [widgets.HTML(html_table)]
        self.btn_export.disabled = self.summary_df.empty

    def _on_export(self, b):
        with self.out: clear_output(wait=True)
        if self.summary_df.empty:
            exibir_erro("Nenhuma tabela de resumo para exportar."); return

        link = gerar_link_download(self.summary_df, nome_arquivo="Resumo_Ajustes_Sigmoidais.xlsx")
        display(link)
        exibir_mensagem("Arquivo com o resumo dos ajustes gerado.")

    def _on_toggle_manual_adjust(self, b):
        is_hidden = self.manual_adjust_container.layout.display == 'none'
        self.manual_adjust_container.layout.display = '' if is_hidden else 'none'
        b.description = "Ocultar Ajuste Manual" if is_hidden else "Editar Parâmetros (p0)"
        if is_hidden and not self.manual_adjust_container.children:
            self._build_manual_adjust_ui()

    def _build_manual_adjust_ui(self):
        records_by_curve: Dict[tuple, List] = defaultdict(list)
        for rec in self.fit_records:
            source_type = rec.metadata.get('source_type')
            if source_type:
                key = (rec.ensaio_id, rec.Ea, source_type)
                records_by_curve[key].append(rec)

        accordion_children = []
        self.manual_widgets = {}

        for key in sorted(records_by_curve.keys()):
            self.manual_widgets[key] = {}
            curve_panel_vbox = widgets.VBox(layout={'border': '1px solid #ddd', 'padding': '10px', 'margin-bottom': '10px'})

            for fit_rec in sorted(records_by_curve[key], key=lambda r: r.metadata.get('model_name', '')):
                model_name = fit_rec.metadata.get('model_name')
                param_names = fit_rec.metadata.get('param_names', [])
                popt = fit_rec.metadata.get('popt', [])

                if not model_name or not param_names: continue

                self.manual_widgets[key][model_name] = {}
                model_widgets = [widgets.HTML(f"<b>Parâmetros Iniciais (p0) para '{model_name.title()}':</b>")]

                for i, name in enumerate(param_names):
                    # Ensure index i is within bounds for popt
                    value = popt[i] if i < len(popt) else 0.0 # Use a default value if index is out of bounds
                    widget = widgets.FloatText(value=value, description=f"{name}:")
                    model_widgets.append(widget)
                    self.manual_widgets[key][model_name][name] = widget

                curve_panel_vbox.children += tuple(model_widgets)

            accordion_children.append(curve_panel_vbox)

        accordion = widgets.Accordion(children=accordion_children, selected_index=None)
        for i, key in enumerate(sorted(records_by_curve.keys())):
            ensaio_id, Ea, source_type = key
            accordion.set_title(i, f"Ensaio {ensaio_id+1} | Ea={Ea:.2f} | Dado: {source_type}")

        self.btn_refit = widgets.Button(description="Salvar e Re-ajustar com p0 Manuais", button_style="danger", icon='cogs')
        self.btn_refit.on_click(self._on_refit)

        self.manual_adjust_container.children = [
            widgets.HTML("<hr><h4>Edição Manual de Parâmetros Iniciais (p0)</h4>"),
            accordion, self.btn_refit
        ]

    def _on_refit(self, b):
        with self.out: clear_output(wait=True)
        exibir_mensagem("Coletando parâmetros manuais para re-ajuste...")

        new_p0_overrides = {}
        for key, models in self.manual_widgets.items():
            new_p0_overrides[key] = {}
            for model_name, params in models.items():
                # Ensure the order of parameters matches the model's param_names
                param_names_order = None
                # Find a fit record for this key and model to get the correct param_names order
                for rec in self.fit_records:
                    if (rec.ensaio_id, rec.Ea, rec.metadata.get('source_type')) == key and rec.metadata.get('model_name') == model_name:
                        param_names_order = rec.metadata.get('param_names')
                        break

                if param_names_order:
                    new_p0 = [params[name].value for name in param_names_order if name in params]
                    new_p0_overrides[key][model_name] = new_p0
                else:
                    with self.out: exibir_erro(f"Não foi possível determinar a ordem dos parâmetros para {model_name} no Ensaio {key[0]+1}, Ea={key[1]}. Pulando.")


        if self.controller and hasattr(self.controller, 'trigger_refit'):
            self.controller.trigger_refit(new_p0_overrides)
        else:
            with self.out: exibir_erro("Controlador ou método 'trigger_refit' não encontrado.")

    def _on_confirm_and_proceed(self, b):
        with self.out: clear_output(wait=True)
        exibir_mensagem("Parâmetros confirmados. Avançando para a análise final...")

        if self.controller and hasattr(self.controller, 'show_module_by_step'):
            self.controller.show_module_by_step('FINAL_ANALYSIS')
        else:
             with self.out: exibir_erro("Controlador ou método de navegação não encontrado.")

# Registra o conteúdo desta célula como um módulo importável
sys.modules['modulo5_3_1_revisao'] = sys.modules[__name__]

# MÓDULO 5_4 Roteador 2 - Formas de Análise dos dados
# modulo5_4_roteador.py

import ipywidgets as widgets
from IPython.display import display, clear_output
from typing import List

# As importações abaixo são necessárias para o funcionamento.
# Elas devem estar definidas em Módulos anteriores do notebook.
# from core import SinteringDataRecord
# from modulo5_4_1_comparaçao import Modulo5_4_1Comparisons
# from modulo5_4_2_Ref import Modulo5_4_2Ref
# from modulo5_4_3_blaine_linear import Modulo5_4_3BlaineLinear
# from modulo1_interface import exibir_mensagem, exibir_erro

class Modulo5_4_Roteador:
    """
    Módulo 5.4.0 Refatorado – Roteador para os métodos de análise final.

    Apresenta ao usuário as opções de análise final (Comparação, Erro Individual,
    Linearização) e, com base na escolha, instancia e exibe o submódulo correspondente,
    passando a lista completa de SinteringDataRecord.
    """

    def __init__(self, sintering_records: List[SinteringDataRecord], controller=None):
        """
        Construtor ajustado para receber a lista de SinteringDataRecord.

        :param sintering_records: A lista completa de dados processados até esta etapa.
        :param controller: Referência ao MainInteractive para navegação.
        """
        # CORREÇÃO: Garante que o nome da variável está correto.
        self.sintering_records = sintering_records
        self.controller = controller
        self.out = widgets.Output()
        self._build_ui()

# Em Modulo5_4_Roteador

    def _build_ui(self):
        # A definição de 'explanation_text' e 'radio_paths' continua a mesma...
        explanation_text = """
        <div style="font-family: Arial, sans-serif; line-height: 1.5;">
            <h2>Módulo 5.4 – Análise Final e Busca da Melhor Ea</h2>
            <p>
                Selecione o método de análise para determinar a Energia de Ativação que melhor representa
                o comportamento de sinterização dos seus dados:
            </p>
            <ul>
                <li><b>1. Comparação de Curvas (MRS/MPCD):</b> Ideal para comparar a 'qualidade' do colapso
                de *múltiplas* curvas para diferentes Ea, encontrando a Ea que gera a "curva mestra" mais coesa.</li>
                <li><b>2. Erro de Ajuste Individual (MSE):</b> Avalia a Ea que resulta no melhor *ajuste sigmoidal
                individual* para cada curva, útil para identificar a 'perfeição' de cada curva isolada.</li>
                <li><b>3. Linearização de Blaine:</b> Transforma os dados (psi ou phi) em uma relação linear
                para diferentes Ea, usando o R² da regressão para avaliar a 'linearidade' do processo.</li>
            </ul>
            <p>
                Após a análise, a melhor Ea encontrada em <b>Comparação de Curvas (MRS/MPCD)</b> pode ser usada
                como estimativa inicial para o <b>Refinamento da Energia de Ativação (Módulo 5.5)</b>, que
                realiza um ajuste global mais preciso e calcula a incerteza estatística.
            </p>
        </div>
        """ # Seu texto de explicação
        self.html_explanation = widgets.HTML(value=explanation_text)

        self.radio_paths = widgets.RadioButtons(
            options=[
                ("1. Comparação de Curvas (MRS/MPCD)", "comparisons"),
                ("2. Erro de Ajuste Individual (MSE)", "individual_error"),
                ("3. Linearização de Blaine", "blaine_linear")
            ],
            value="comparisons",
            # A description longa pode ser removida e colocada em um HTML separado
        )

        # Botões
        self.btn_proceed = widgets.Button(description="Executar Análise", button_style='success')
        self.btn_proceed.on_click(self._on_proceed_clicked)
        self.btn_back = widgets.Button(description="Voltar (p/ Módulo 5.3)", button_style='warning')
        self.btn_back.on_click(self._on_back_clicked)

        # --- SOLUÇÃO PARA O LAYOUT ---
        # Colocamos o RadioButtons dentro de uma VBox para garantir a disposição vertical.
        self.main_ui = widgets.VBox([
            self.html_explanation,
            widgets.HTML("<b>Escolha o método de análise final:</b>"),
            widgets.VBox([self.radio_paths]), # <-- MUDANÇA AQUI
            widgets.HBox([self.btn_back, self.btn_proceed]),
            self.out
        ])

    def display(self):
        """Exibe a interface principal do roteador."""
        # Use parent's controls_container if available, otherwise display directly
        if self.controller and hasattr(self.controller, 'controls_container'):
            self.controller.controls_container.children = [self.main_ui]
        else:
            clear_output(wait=True)
            display(self.main_ui)


    def _on_proceed_clicked(self, b):
        """
        Callback para o botão 'Executar Análise'.
        Instancia o submódulo escolhido, passando a lista de SinteringDataRecord.
        """
        with self.out:
            clear_output()

        choice = self.radio_paths.value

        # Passa 'self.sintering_records' para os construtores dos submódulos
        if choice == "comparisons":
            mod = Modulo5_4_1Comparisons(self.sintering_records, parent=self.controller) # Pass controller as parent
            mod.display() # Call display on the module
        elif choice == "individual_error":
            mod = Modulo5_4_2Ref(self.sintering_records, parent=self.controller) # Pass controller as parent
            mod.display() # Call display on the module
        elif choice == "blaine_linear":
            mod = Modulo5_4_3BlaineLinear(self.sintering_records, parent=self.controller) # Pass controller as parent
            mod.display() # Call display on the module

    def _on_back_clicked(self, b):
        """
        Callback para o botão 'Voltar'.
        Chama um método no controlador principal para navegar para a tela anterior.
        """
        with self.out:
            clear_output()

        if self.controller and hasattr(self.controller, 'show_module_by_step'):
            exibir_mensagem("Retornando ao Módulo 5.3 (Ajuste Sigmoidal)...")
            # O passo 'REVIEW' no MainInteractive corresponde ao Módulo 5.3.1 (que vem após o 5.3)
            # Need to go back to the step BEFORE 'FINAL_ANALYSIS', which is 'REVIEW'
            self.controller.show_module_by_step('REVIEW')
        else:
            exibir_erro("Controlador ou método de retorno não foi encontrado.")
import sys
sys.modules['modulo5_4_roteador'] = sys.modules[__name__]

import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from scipy.optimize import curve_fit
from typing import List, Callable
from collections import defaultdict
import matplotlib.pyplot as plt
import sys

# Importando do seu arquivo core
from core import (
    SinteringDataRecord, exibir_mensagem, exibir_erro, gerar_link_download,
    boltzmann_sigmoid, generalized_logistic_stable
)

class Modulo5_4_1Comparisons:
    """
    Submódulo 5.4.1 – Comparações (MRS e MPCD) com exibição de resultados aprimorada.
    """
    def __init__(self, sintering_records: List[SinteringDataRecord], parent=None, fig_out=None):
        self.all_records = sintering_records
        self.parent = parent
        self.results_df = None
        self.comparison_details_df = None
        self.out = widgets.Output()
        self.fig_out = fig_out if fig_out is not None else self.out
        self._build_ui()

    def _build_ui(self):
        # Gera as opções de seleção dinamicamente
        self.DATA_OPTIONS_MAP = {}
        fit_records = [rec for rec in self.all_records if rec.tipo_dado_y.startswith('fit_')]

        for rec in fit_records:
            internal_type = rec.tipo_dado_y
            model_name = rec.metadata.get('model_name', 'desconhecido').title()
            source_type = rec.metadata.get('source_type', 'desconhecido').replace('_', ' ').title()
            ui_text = f"Ajuste {model_name} ({source_type})"
            if ui_text not in self.DATA_OPTIONS_MAP:
                self.DATA_OPTIONS_MAP[ui_text] = internal_type

        self.available_options = sorted(list(self.DATA_OPTIONS_MAP.keys()))

        if not self.available_options:
            self.main_ui = widgets.HTML("<b>Nenhum resultado de ajuste compatível foi encontrado.</b>")
            return

        self.select_data = widgets.SelectMultiple(
            options=self.available_options, description="Comparar curvas de:",
            rows=min(len(self.available_options), 8), style={'description_width': 'initial'}
        )
        self.radio_method = widgets.RadioButtons(
            options=[("Mean Residual Square (MRS)", "mrs"), ("Mean Perpendicular Curve Distance (MPCD)", "mpcd")],
            value="mrs", description="Critério Padrão:", style={'description_width': 'initial'}
        )
        self.btn_compare = widgets.Button(description="Executar Comparação", button_style='success', icon='calculator')
        self.btn_visualize_error = widgets.Button(description="Visualizar Erro", button_style='info', icon='line-chart', disabled=True)
        self.btn_refine = widgets.Button(description="Refinar Melhor Resultado", button_style='success', icon='cogs', disabled=True)
        self.btn_export = widgets.Button(description="Exportar", button_style='info', disabled=True, icon='download')
        self.btn_back = widgets.Button(description="Voltar", button_style='warning', icon='arrow-left')

        self.btn_compare.on_click(self._on_compare)
        self.btn_visualize_error.on_click(self._on_visualize_error_curves)
        self.btn_refine.on_click(self._on_start_refinement)
        self.btn_export.on_click(self._on_export)
        self.btn_back.on_click(self._on_back_clicked)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.4.1 – Comparação e Busca da Melhor Ea</h3>"),
            self.select_data, self.radio_method,
            widgets.HBox([self.btn_back, self.btn_compare, self.btn_visualize_error, self.btn_refine, self.btn_export]),
            self.out
        ])

    def display(self):
        # ... (método display permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _on_compare(self, b):
        with self.out: clear_output(wait=True); exibir_mensagem("Iniciando comparação...")

        self.btn_export.disabled = self.btn_visualize_error.disabled = self.btn_refine.disabled = True

        selected_ui_options = self.select_data.value
        if not selected_ui_options:
            exibir_erro("Por favor, selecione pelo menos um conjunto de dados para comparar."); return

        selected_internal_types = [self.DATA_OPTIONS_MAP[opt] for opt in selected_ui_options]
        all_results, all_details = [], []

        for data_type in selected_internal_types:
            model_func = generalized_logistic_stable if 'logistic' in data_type else boltzmann_sigmoid
            for method in ["mrs", "mpcd"]:
                # ... (lógica de cálculo de erro permanece a mesma) ...
                pass

        if all_results:
            self.results_df = pd.DataFrame(all_results)
            self.comparison_details_df = pd.DataFrame(all_details)

            # --- CORREÇÃO: Exibição dos resultados em um Accordion ---
            with self.out:
                clear_output(wait=True)
                display(HTML("<h4>Resumo: Melhores Energias de Ativação Encontradas</h4>"))
                display(self.results_df.style.format({'Melhor_Ea_kJ_mol': '{:.2f}', 'Erro_Minimo': '{:.6g}'}))

                # Cria a caixa colapsável para os detalhes
                details_html = self.comparison_details_df.style.format({'Ea_kJ_mol': '{:.2f}', 'Erro': '{:.6g}'}).to_html()
                accordion = widgets.Accordion(children=[widgets.HTML(details_html)], selected_index=None)
                accordion.set_title(0, "Ver Detalhes do Cálculo de Erro")
                display(accordion)

            self.btn_export.disabled = self.btn_visualize_error.disabled = self.btn_refine.disabled = False
        else:
            with self.out: exibir_erro("Nenhum resultado de comparação válido gerado.")

    def _calculate_mrs_for_ea(self, curves_data: List[np.ndarray], model_func: Callable) -> float:
        # ... (método _calculate_mrs_for_ea permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _calculate_mpcd_for_ea(self, curves_data: List[np.ndarray], model_func: Callable) -> float:
        # ... (método _calculate_mpcd_for_ea permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _on_visualize_error_curves(self, b):
        # ... (método _on_visualize_error_curves permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _on_start_refinement(self, b):
        # ... (método _on_start_refinement permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _on_export(self, b):
        # ... (método _on_export permanece o mesmo) ...
        pass # Placeholder for the actual implementation

    def _on_back_clicked(self, b):
        # ... (método _on_back_clicked permanece o mesmo) ...
        pass # Placeholder for the actual implementation

# Registra o módulo
sys.modules['modulo5_4_1_comparaçao'] = sys.modules[__name__]

# MÓDULO 5_4_2 Determinação de Erro Médio para um Ensaio
# modulo5_4_2_Ref.py

import ipywidgets as widgets
from IPython.display import display, clear_output
from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
from typing import List
from collections import defaultdict

# Importações necessárias do Módulo 1
from modulo1_interface import (
    SinteringDataRecord,
    exibir_mensagem,
    exibir_erro,
    boltzmann_sigmoid
)

class Modulo5_4_2Ref:
    """
    Submódulo 5.4.2 Refatorado – Método de Erro de Ajuste Individual (MSE).

    Encontra a melhor Energia de Ativação (Ea) para cada curva individualmente,
    identificando qual valor de Ea, dentre os já calculados, resulta em uma curva
    com o menor erro quadrático médio (MSE) ao ser ajustada por uma função sigmoidal.
    """
    def __init__(self, sintering_records: List[SinteringDataRecord], parent=None):
        self.all_records = sintering_records
        self.parent = parent
        self.results_df = None
        self.out = widgets.Output()
        self._build_ui()

    def _build_ui(self):
        # Mapeamento da UI para os tipos de dados internos
        self.DATA_OPTIONS_MAP = {
            "Densidade Alinhada": "dados_alinhados",
            "Parâmetro Psi (ψ)": "psi",
            "Parâmetro Phi (φ)": "phi",
            "Densidade Original": "densidade_original"
        }

        # Filtra as opções disponíveis conforme registros
        available_types = set(rec.tipo_dado_y for rec in self.all_records)
        options = [ui for ui, itype in self.DATA_OPTIONS_MAP.items() if itype in available_types]

        if not options:
            self.main_ui = widgets.HTML("<b>Nenhum tipo de dado compatível com este método foi encontrado.</b>")
            return

        self.select_data = widgets.Dropdown(
            options=options,
            description="Analisar dados de:",
            style={'description_width': 'initial'}
        )

        self.btn_calc = widgets.Button(
            description="Calcular Melhor Ea (por Erro Individual)",
            button_style='success'
        )
        self.btn_calc.on_click(self._on_calc)

        self.btn_back = widgets.Button(
            description="Voltar",
            button_style='warning'
        )
        self.btn_back.on_click(self._on_back_clicked)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.4.2 – Método de Erro de Ajuste Individual</h3>"),
            widgets.HTML("<p>Este método avalia qual das Energias de Ativação já calculadas produz a curva mais 'perfeita' (com menor erro de auto-ajuste) para cada ensaio.</p>"),
            self.select_data,
            widgets.HBox([self.btn_back, self.btn_calc]),
            self.out
        ])

    def display(self):
        """Exibe a interface principal do módulo."""
        display(self.main_ui)

    def _calc_mse_error(self, x_vals, y_vals):
        """Calcula o erro quadrático médio (MSE) de um ajuste Boltzmann."""
        if len(x_vals) < 4:
            return np.inf
        try:
            p0 = [
                np.max(y_vals),
                np.min(y_vals),
                np.median(x_vals),
                (np.max(x_vals) - np.min(x_vals)) / 4
            ]
            popt, _ = curve_fit(
                boltzmann_sigmoid,
                x_vals,
                y_vals,
                p0=p0,
                maxfev=5000
            )
            y_pred = boltzmann_sigmoid(x_vals, *popt)
            return np.mean((y_vals - y_pred) ** 2)
        except Exception:
            return np.inf

    def _on_calc(self, b):
        with self.out:
            clear_output()
            selected_ui = self.select_data.value
            selected_type = self.DATA_OPTIONS_MAP[selected_ui]

            # Filtra registros conforme tipo selecionado
            records_to_process = [
                rec for rec in self.all_records
                if rec.tipo_dado_y == selected_type
            ]
            if not records_to_process:
                exibir_erro(f"Nenhum dado do tipo '{selected_type}' foi encontrado para análise.")
                return

            results_by_ensaio = defaultdict(dict)
            for rec in records_to_process:
                df_clean = rec.df.dropna()
                x_col = next((c for c in df_clean.columns if 'logtheta' in c), None)
                y_col = next((c for c in df_clean.columns if 'valor' in c), None)
                if x_col is None or y_col is None:
                    continue

                error = self._calc_mse_error(
                    df_clean[x_col].values,
                    df_clean[y_col].values
                )
                if np.isfinite(error):
                    results_by_ensaio[rec.ensaio_id][rec.Ea] = error

            summary_list = []
            for ens_id, ea_errors in results_by_ensaio.items():
                if not ea_errors:
                    continue
                best_ea = min(ea_errors, key=ea_errors.get)
                summary_list.append({
                    "Ensaio_ID": ens_id + 1,
                    "Tipo de Dado": selected_type,
                    "Melhor_Ea (kJ/mol)": best_ea,
                    "Min_MSE": ea_errors[best_ea]
                })

            if summary_list:
                self.results_df = pd.DataFrame(summary_list)
                exibir_mensagem("--- MELHOR Ea POR ENSAIO (MÉTODO DE ERRO INDIVIDUAL) ---")
                display(self.results_df.style.format({
                    'Melhor_Ea (kJ/mol)': '{:.2f}',
                    'Min_MSE': '{:.6g}'
                }))
            else:
                exibir_erro("Não foi possível calcular nenhum resultado válido.")

    def _on_back_clicked(self, b):
        with self.out:
            clear_output()
        if self.parent and hasattr(self.parent, 'show_module_by_step'):
            # Go back to the final analysis router
            self.parent.show_module_by_step('FINAL_ANALYSIS')
        elif self.parent and hasattr(self.parent, 'display'):
            self.parent.display()
        else:
            exibir_erro("Controlador ou método de retorno não encontrado.")

# MÓDULO 5_4_3 Linearização da Curva Mestra
# modulo5_4_3_blaine_linear.py

import ipywidgets as widgets
from IPython.display import display, clear_output
import numpy as np
import pandas as pd
from scipy.stats import linregress
import matplotlib.pyplot as plt
from typing import List

from modulo1_interface import SinteringDataRecord, exibir_mensagem, exibir_erro

class Modulo5_4_3BlaineLinear:
    """
    Submódulo 5.4.3 – Método de Linearização de Blaine.
    Aplica uma transformação linearizante a dados de 'psi' ou 'phi' e
    realiza regressão linear para avaliar a qualidade do ajuste (R²).
    """

    def __init__(self, sintering_records: List[SinteringDataRecord], parent=None):
        self.all_records = sintering_records
        self.parent = parent
        self.results_df = None
        self.out = widgets.Output()
        self._build_ui()

    def _build_ui(self):
        # Mapeamento fixo, mas só mostra o que existe nos records
        self.DATA_OPTIONS_MAP = {
            "Parâmetro Psi (ψ)": "psi",
            "Parâmetro Phi (φ)": "phi"
        }
        available = [ui for ui, it in self.DATA_OPTIONS_MAP.items()
                     if any(rec.tipo_dado_y == it for rec in self.all_records)]
        if not available:
            self.main_ui = widgets.HTML("<b>Nenhum dado 'psi' ou 'phi' disponível para linearização.</b>")
            return

        self.select_param = widgets.Dropdown(
            options=available,
            description="Linearizar:",
            style={'description_width': 'initial'}
        )
        self.btn_linearize = widgets.Button(description="Executar Linearização", button_style='success')
        self.btn_linearize.on_click(self._on_linearize)

        self.btn_plot = widgets.Button(description="Visualizar Linearização", button_style='warning')
        self.btn_plot.on_click(self._on_plot)

        self.btn_back = widgets.Button(description="Voltar", button_style='warning')
        self.btn_back.on_click(self._on_back_clicked)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.4.3 – Método de Linearização de Blaine</h3>"),
            widgets.HTML("<p>Transformação e regressão linear em 'psi' ou 'phi', exibindo R².</p>"),
            self.select_param,
            widgets.HBox([self.btn_linearize, self.btn_plot, self.btn_back]),
            self.out
        ])

    def display(self):
        # Use parent's controls_container if available, otherwise display directly
        if self.parent and hasattr(self.parent, 'controls_container'):
            self.parent.controls_container.children = [self.main_ui]
        else:
            clear_output(wait=True)
            display(self.main_ui)

    def _on_linearize(self, b):
        with self.out:
            clear_output()
        param_choice = self.DATA_OPTIONS_MAP[self.select_param.value]
        records = [rec for rec in self.all_records if rec.tipo_dado_y == param_choice]
        if not records:
            exibir_erro(f"Nenhum dado do tipo '{param_choice}' encontrado para linearizar.")
            return

        results = []
        for rec in records:
            df = rec.df.dropna()
            x_col = next((c for c in df.columns if c.startswith('logtheta')), None)
            y_col = next((c for c in df.columns if c.startswith('valor')), None)
            if x_col is None or y_col is None:
                exibir_erro(f"Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}: colunas não encontradas.")
                continue

            x_vals = df[x_col].values
            y_vals = df[y_col].values

            try:
                if param_choice == 'psi':
                    mask = (y_vals > 1e-9) & (y_vals < 1 - 1e-9)
                    x_t = x_vals[mask]
                    y_t = np.log(y_vals[mask] / (1 - y_vals[mask]))
                else:  # 'phi'
                    mask = y_vals > 1e-9
                    x_t = x_vals[mask]
                    y_t = np.log(y_vals[mask])

                if len(x_t) < 2:
                    exibir_erro(f"Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}: dados insuficientes após máscara.")
                    continue

                slope, intercept, r_value, _, _ = linregress(x_t, y_t)
                results.append({
                    "Ensaio_ID": rec.ensaio_id + 1,
                    "Ea_kJ_mol": rec.Ea,
                    "DataType": param_choice,
                    "R_squared": r_value**2,
                    "Slope": slope,
                    "Intercept": intercept
                })
            except Exception as e:
                exibir_erro(f"Erro na regressão Ensaio {rec.ensaio_id+1}, Ea={rec.Ea}: {e}")

        if results:
            self.results_df = pd.DataFrame(results).sort_values(by="R_squared", ascending=False)
            with self.out:
                exibir_mensagem("Linearização concluída. Resultados ordenados por R²:")
                display(self.results_df.style.format({'R_squared': '{:.4f}', 'Slope': '{:.4f}', 'Intercept': '{:.4f}'}))
        else:
            exibir_erro("Nenhum resultado de linearização pôde ser calculado.")

    def _on_plot(self, b):
        with self.out:
            clear_output()
        if self.results_df is None or self.results_df.empty:
            exibir_erro("Nenhum resultado disponível. Execute 'Executar Linearização' primeiro.")
            return

        param_choice = self.DATA_OPTIONS_MAP[self.select_param.value]
        records = [rec for rec in self.all_records if rec.tipo_dado_y == param_choice]
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.set_title(f"Linearização de {param_choice.upper()} – Dados vs. Ajuste")
        ax.set_xlabel("log(theta)")
        ylabel = "ln(ψ/(1-ψ))" if param_choice == 'psi' else "ln(φ)"
        ax.set_ylabel(ylabel)

        for rec in records:
            df = rec.df.dropna()
            x_col = next((c for c in df.columns if c.startswith('logtheta')), None)
            y_col = next((c for c in df.columns if c.startswith('valor')), None)
            x_vals = df[x_col].values
            y_vals = df[y_col].values

            if param_choice == 'psi':
                mask = (y_vals > 1e-9) & (y_vals < 1 - 1e-9)
                x_t = x_vals[mask]
                y_t = np.log(y_vals[mask] / (1 - y_vals[mask]))
            else:
                mask = y_vals > 1e-9
                x_t = x_vals[mask]
                y_t = np.log(y_vals[mask])

            if len(x_t) < 2:
                continue

            slope = self.results_df.query(
                "Ensaio_ID==@ (rec.ensaio_id+1) & Ea_kJ_mol==@rec.Ea"
            )['Slope'].iloc[0]
            intercept = self.results_df.query(
                "Ensaio_ID==@ (rec.ensaio_id+1) & Ea_kJ_mol==@rec.Ea"
            )['Intercept'].iloc[0]

            y_fit = slope * x_t + intercept
            label = f"E{rec.ensaio_id+1} Ea={rec.Ea:.2f}"
            ax.plot(x_t, y_t, 'o', ms=4, label=f"{label} (dados)")
            ax.plot(x_t, y_fit, '-', label=f"{label} (fit R²={self.results_df.loc[(self.results_df['Ensaio_ID']==rec.ensaio_id+1)&(self.results_df['Ea_kJ_mol']==rec.Ea),'R_squared'].iloc[0]:.3f})")

        ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        ax.grid(True)
        plt.tight_layout()
        plt.show()
        with self.out:
            exibir_mensagem("Visualização de linearização concluída.")

    def _on_back_clicked(self, b):
        with self.out:
            clear_output()
        if self.parent and hasattr(self.parent, 'show_module_by_step'):
            # Go back to the final analysis router
            self.parent.show_module_by_step('FINAL_ANALYSIS')
        elif self.parent and hasattr(self.parent, 'display'):
            self.parent.display()
        else:
            exibir_erro("Controlador (parent) ou método de retorno não encontrado.")

import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
from typing import List, Dict, Optional, Callable
from scipy.optimize import least_squares, curve_fit
import matplotlib.pyplot as plt
import sys

# Importando do seu arquivo core
from core import (
    SinteringDataRecord, exibir_mensagem, exibir_erro, R, cumtrapz,
    boltzmann_sigmoid, generalized_logistic_stable
)

class Modulo5_5_Refinamento:
    """
    Módulo 5.5 – Refinamento da Energia de Ativação e Cálculo de Incerteza.
    Versão com processo de ajuste interno mais estável.
    """
    def __init__(self,
                 sintering_records: List[SinteringDataRecord],
                 initial_ea: float,
                 target_curve_type: str,
                 parent=None,
                 fig_out: Optional[widgets.Output] = None):

        self.all_records = sintering_records
        self.initial_ea = initial_ea
        self.target_curve_type = target_curve_type
        self.parent = parent
        self.final_ea: Optional[float] = None
        self.confidence_interval: Optional[float] = None
        self.objective_function_model: Optional[Callable] = None
        self.source_data_type: Optional[str] = None
        self.source_records: List[SinteringDataRecord] = []
        self.original_exp_records: Dict[int, SinteringDataRecord] = {}

        self.out = widgets.Output()
        # Usa o fig_out do controlador, se disponível, para consistência de layout
        self.fig_out = fig_out if fig_out is not None else self.out

        self._build_ui()
        self.run_refinement()

    def _prepare_data_and_model(self):
        """
        Prepara os dados de origem, mapeia os dados experimentais originais
        e seleciona o modelo de ajuste com base no tipo de curva alvo.
        """
        self.source_data_type = self.target_curve_type.replace('fit_boltzmann_', '').replace('fit_logistic_', '')

        if 'boltzmann' in self.target_curve_type:
            self.objective_function_model = boltzmann_sigmoid
        elif 'logistic' in self.target_curve_type:
            self.objective_function_model = generalized_logistic_stable
        else:
            raise ValueError(f"Tipo de curva alvo desconhecido: {self.target_curve_type}")

        self.source_records = [rec for rec in self.all_records if rec.tipo_dado_y == self.source_data_type]
        self.original_exp_records = {rec.ensaio_id: rec for rec in self.all_records if rec.tipo_dado_y == 'densidade_original'}

        if not self.source_records: raise ValueError(f"Nenhum record do tipo '{self.source_data_type}' encontrado.")
        if not self.original_exp_records: raise ValueError("Nenhum record de 'densidade_original' encontrado.")

    def _objective_function(self, ea_array: np.ndarray) -> np.ndarray:
        """
        Função de erro para o otimizador, com ajuste de curva mestra robusto.
        """
        Ea_kj = ea_array[0]
        Ea_j = Ea_kj * 1000.0
        all_points_list = []

        for rec in self.source_records:
            original_rec = self.original_exp_records.get(rec.ensaio_id)
            if original_rec is None: continue

            time_col = next((c for c in original_rec.df.columns if c.startswith('Time_s')), None)
            temp_col = next((c for c in original_rec.df.columns if c.startswith('Temperature_C')), None)
            if not time_col or not temp_col: continue

            t_vals, T_k = original_rec.df[time_col].values, original_rec.df[temp_col].values + 273.15

            theta_inst = (1.0 / T_k) * np.exp(-Ea_j / (R * T_k))
            integrated = cumtrapz(theta_inst, t_vals, initial=0)
            with np.errstate(divide='ignore', invalid='ignore'):
                log_integrated = np.log10(integrated)

            df_recalc = pd.DataFrame({'logtheta': log_integrated, 'y_valor': rec.df['valor'].values}).dropna()
            all_points_list.append(df_recalc)

        if not all_points_list: return np.array([1e6])

        master_df = pd.concat(all_points_list, ignore_index=True)
        x_data, y_data = master_df['logtheta'].values, master_df['y_valor'].values

        try:
            # --- CORREÇÃO: Adicionados limites (bounds) para estabilizar o ajuste ---
            x_range = np.ptp(x_data) if len(x_data) > 1 else 1.0
            p0_A1, p0_A2, p0_x0 = np.max(y_data), np.min(y_data), np.median(x_data)

            if self.objective_function_model == generalized_logistic_stable:
                p0 = [p0_A1, p0_A2, p0_x0, x_range / 4, 1.0]
                bounds = (
                    [p0_A2*0.9, p0_A1*0.9, x_data.min()-x_range, 1e-9, 0.1],
                    [p0_A2*1.1, p0_A1*1.1, x_data.max()+x_range, x_range*5, 10.0]
                )
            else: # Boltzmann
                p0 = [p0_A1, p0_A2, p0_x0, x_range / 4]
                bounds = (
                    [p0_A2*0.9, p0_A1*0.9, x_data.min()-x_range, 1e-9],
                    [p0_A2*1.1, p0_A1*1.1, x_data.max()+x_range, x_range*5]
                )

            popt, _ = curve_fit(self.objective_function_model, x_data, y_data, p0=p0, bounds=bounds, maxfev=8000)
            return y_data - self.objective_function_model(x_data, *popt)
        except (RuntimeError, ValueError):
            return np.full_like(y_data, 1e6)

    def run_refinement(self):
        with self.out: clear_output(); exibir_mensagem("Executando refinamento não linear...")
        try:
            self._prepare_data_and_model()
            result = least_squares(fun=self._objective_function, x0=[self.initial_ea], method='trf', bounds=([10], [5000]))
            self.final_ea = result.x[0]

            jac = result.jac
            cov_inv = jac.T.dot(jac) + 1e-8 * np.eye(jac.shape[1])
            pcov = np.linalg.inv(cov_inv)
            std_err = np.sqrt(np.diag(pcov))
            self.confidence_interval = 1.96 * std_err[0]
        except Exception as e:
            with self.out: exibir_erro(f"Erro crítico durante o refinamento: {e}"); return

        self._update_results_display()

    def _build_ui(self):
        self.results_container = widgets.VBox([widgets.HTML("<h4>Calculando...</h4>")])
        self.btn_back = widgets.Button(description="Voltar para Análise", button_style='warning', icon='arrow-left')
        self.btn_back.on_click(self._on_back_clicked)
        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Submódulo 5.5 – Refinamento da Energia de Ativação</h3>"),
            self.results_container, self.btn_back, self.out
        ])

    def _update_results_display(self):
        if self.final_ea is None or self.confidence_interval is None:
            self.results_container.children = [widgets.HTML("<p style='color:red;'>Falha ao calcular o resultado final.</p>")]
            return

        resultado_html = f"""
        <div style="border: 1px solid #ccc; padding: 15px; border-radius: 5px; background-color: #f9f9f9;">
            <p>A partir de um valor inicial de <b>{self.initial_ea:.2f} kJ/mol</b>, o ajuste fino convergiu para:</p>
            <h1 style="text-align: center; color: #28a745; margin: 10px 0;">
                Ea = {self.final_ea:.2f} &pm; {self.confidence_interval:.2f} kJ/mol
            </h1>
            <p style="text-align: center; font-style: italic;">(Intervalo de Confiança de 95%)</p>
        </div>
        """
        self.results_container.children = [widgets.HTML(resultado_html)]

    def _on_back_clicked(self, b):
        if self.parent and hasattr(self.parent, 'show_module_by_step'):
            self.parent.show_module_by_step('FINAL_ANALYSIS')
        else:
            with self.out: exibir_erro("Controlador principal não encontrado.")

    def display(self):
        if self.parent and hasattr(self.parent, 'controls_container'):
            self.parent.controls_container.children = [self.main_ui]
            with self.parent.figure_container: clear_output()
        else:
            display(self.main_ui)

# Registra o conteúdo desta célula como um módulo importável
sys.modules['modulo5_5_refinamento'] = sys.modules[__name__]

# MÓDULO 6.0 Início Método Arhernius - Derivadas
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
from scipy.signal import savgol_filter
from scipy.interpolate import interp1d

# Importações de utilitários do Módulo 1
from modulo1_interface import exibir_mensagem, exibir_erro, gerar_link_download


def _calculate_derivatives_robust(df: pd.DataFrame, time_col: str, temp_col: str, dens_col: str):
    """
    Calcula derivadas de T e p em relação ao tempo e à temperatura,
    aplicando filtro Savitzky-Golay para suavização prévia.
    Retorna interpoladores de T(dens), dT/dt(dens) e dp/dT(dens).
    """
    # Ordena e copia
    df_sorted = df.sort_values(time_col).reset_index(drop=True)
    n_pts = len(df_sorted)
    if n_pts < 5:
        raise ValueError("Dados insuficientes (<5 pontos) para cálculo robusto.")

    # Determina janela ímpar para filtro
    max_win = 11
    win = min(max_win, n_pts if n_pts % 2 == 1 else n_pts - 1)
    window_length = win if win >= 5 else (5 if n_pts >= 5 else n_pts)
    if window_length >= 5:
        y_vals = savgol_filter(df_sorted[dens_col].values, window_length, 2)
        T_vals = savgol_filter(df_sorted[temp_col].values + 273.15, window_length, 2)
    else:
        y_vals = df_sorted[dens_col].values
        T_vals = df_sorted[temp_col].values + 273.15

    # Derivadas
    dTdt = np.gradient(T_vals, df_sorted[time_col].values)
    dpdT = np.gradient(y_vals, T_vals)

    # Prepara para interpolação: garante densidade estritamente crescente
    interp_df = pd.DataFrame({
        'dens': y_vals,
        'T': T_vals,
        'dTdt': dTdt,
        'dpdT': dpdT
    }).sort_values('dens').drop_duplicates('dens')

    if len(interp_df) < 2:
        raise ValueError("Dados insuficientes após filtragem para interpolação.")

    f_T = interp1d(interp_df['dens'], interp_df['T'], kind='linear', bounds_error=False, fill_value='extrapolate')
    f_dTdt = interp1d(interp_df['dens'], interp_df['dTdt'], kind='linear', bounds_error=False, fill_value='extrapolate')
    f_dpdT = interp1d(interp_df['dens'], interp_df['dpdT'], kind='linear', bounds_error=False, fill_value='extrapolate')

    return f_T, f_dTdt, f_dpdT


class Modulo6_0_Arrhenius:
    """
    Módulo 6.0 – Cálculo de Curvas de Arrhenius.
    """

    def __init__(self, dfs_ensaios: list):
        self.dfs_ensaios = dfs_ensaios
        self.arrhenius_results = {}

        # Botões
        self.btn_calc = widgets.Button(description="Calcular Arrhenius", button_style='success')
        self.btn_export = widgets.Button(description="Exportar Resultados Arrhenius", button_style='info')
        self.out = widgets.Output()

        self.btn_calc.on_click(self._on_calc)
        self.btn_export.on_click(self._on_export)

        self.main_ui = widgets.VBox([
            widgets.HTML("<h3>Módulo 6.0 – Cálculo de Arrhenius</h3>"),
            widgets.HTML("<p>Calcule ln[(dρ/dt)/T] vs. 1/T para diferentes valores de densidade.</p>"),
            widgets.HBox([self.btn_calc, self.btn_export]),
            self.out
        ])

    def display(self):
        clear_output(wait=True)
        display(self.main_ui)

    def _on_calc(self, _b):
        with self.out:
            clear_output()
            exibir_mensagem("Iniciando cálculo de Arrhenius para todos os ensaios...")

        self.arrhenius_results.clear()

        for idx, df in enumerate(self.dfs_ensaios):
            time_col = next((c for c in df.columns if c.startswith('Time_s')), None)
            temp_col = next((c for c in df.columns if c.startswith('Temperature_C')), None)
            dens_col = next((c for c in df.columns if c.startswith('DensidadePct')), None)

            if not all([time_col, temp_col, dens_col]):
                with self.out:
                    exibir_erro(f"Ensaio {idx+1}: colunas necessárias faltando. Pulando.")
                continue

            df_clean = df.dropna(subset=[time_col, temp_col, dens_col])
            if len(df_clean) < 5:
                with self.out:
                    exibir_erro(f"Ensaio {idx+1}: insuficiente para análise (<5 pontos). Pulando.")
                continue

            dens_min, dens_max = df_clean[dens_col].min(), df_clean[dens_col].max()
            if dens_max <= dens_min:
                with self.out:
                    exibir_erro(f"Ensaio {idx+1}: densidade constante. Pulando.")
                continue

            # Gera alvos de densidade espaçados
            n_points = 10
            dens_targets = np.linspace(
                dens_min + 0.1*(dens_max-dens_min),
                dens_max - 0.1*(dens_max-dens_min),
                n_points
            )

            try:
                f_T, f_dTdt, f_dpdT = _calculate_derivatives_robust(
                    df_clean, time_col, temp_col, dens_col
                )
            except Exception as e:
                with self.out:
                    exibir_erro(f"Ensaio {idx+1}: falha derivadas - {e}")
                continue

            results = []
            for dens in dens_targets:
                T_val = f_T(dens)
                dTdt_val = f_dTdt(dens)
                dpdT_val = f_dpdT(dens)
                if any([not np.isfinite(T_val), not np.isfinite(dTdt_val), not np.isfinite(dpdT_val)]):
                    continue
                if T_val <= 0 or dTdt_val <= 0 or dpdT_val <= 0:
                    continue

                taxa = dpdT_val * dTdt_val
                if taxa <= 0:
                    continue

                ln_term = np.log(taxa / T_val)
                inv_T = 1.0 / T_val
                results.append((dens, inv_T, ln_term))

            self.arrhenius_results[idx] = results

        with self.out:
            exibir_mensagem("Cálculo de Arrhenius concluído para todos os ensaios.")

    def _on_export(self, _b):
        with self.out:
            clear_output()

        if not self.arrhenius_results or not any(self.arrhenius_results.values()):
            exibir_erro("Nenhum resultado para exportar. Execute o cálculo primeiro.")
            return

        exibir_mensagem("Preparando exportação...")
        df_list = []
        for idx, data in self.arrhenius_results.items():
            if not data:
                continue
            df_temp = pd.DataFrame(data, columns=['DensidadePct', 'InvT', 'ln_Rate_div_T'])
            df_temp['Ensaio'] = idx + 1
            df_list.append(df_temp)

        if not df_list:
            with self.out:
                exibir_erro("Nenhum dado válido para exportar.")
            return

        df_export = pd.concat(df_list, ignore_index=True)
        link = gerar_link_download(df_export, nome_arquivo="Arrhenius_Results.xlsx")
        display(link)
        exibir_mensagem("Exportação de Arrhenius concluída.")

    def get_results(self):
        return self.arrhenius_results
import sys
sys.modules['modulo6_0_arrhenius'] = sys.modules[__name__]

# MÓDULO 6_1 Exibição das Curvas de Arrhenius
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
import numpy as np
import pandas as pd
from scipy.stats import linregress
from collections import defaultdict

# Utilitários do Módulo 1
from modulo1_interface import exibir_mensagem, exibir_erro, gerar_link_download, R

class Modulo6_1ArrheniusDisplay:
    """
    Submódulo para Exibição de Curvas Arrhenius e Tabela de Ea

    1) Recebe arrhenius_results (dict) do passo anterior:
       arrhenius_results[i] = [(dens, inv_T, lnVal), ...]
    2) Combina os pontos de todos os ensaios e agrupa por densidade.
    3) Faz regressão linear ln(...) vs. 1/T para cada densidade.
    4) Exibe gráfico único com todas as densidades e retas,
       e gera tabela 'dens vs Ea'.
    5) Exporta em Excel e possui botão Back.
    """

    def __init__(self, arrhenius_results: dict, n_ensaios: int, parent=None):
        self.arrhenius_results = arrhenius_results
        self.n_ensaios = n_ensaios
        self.parent = parent
        self.results_df = None

        self.out = widgets.Output()
        self.btn_plot = widgets.Button(description="Plotar & Mostrar Tabela", button_style='success')
        self.btn_export = widgets.Button(description="Exportar Tabela de Ea", button_style='info', disabled=True)
        self.btn_back = widgets.Button(description="Voltar", button_style='warning')

        self.btn_plot.on_click(self._on_plot)
        self.btn_export.on_click(self._on_export)
        self.btn_back.on_click(self._on_back_clicked)

        self._build_ui()

    def _build_ui(self):
        if self.n_ensaios < 2:
            self.main_ui = widgets.HTML(
                "<b>O método de Arrhenius requer pelo menos 2 ensaios com taxas de aquecimento distintas.</b>"
            )
        else:
            explanation = (
                "<div style='font-family: Arial, sans-serif; line-height: 1.5;'>"
                "<h3>Visualização da Análise de Arrhenius</h3>"
                "<p>Combina pontos (ln(taxa/T) vs. 1/T) de todos os ensaios, agrupando por densidade.</p>"
                "<p>Cada grupo passa por regressão linear: Ea = -slope × R.</p>"
                "</div>"
            )
            self.main_ui = widgets.VBox([
                widgets.HTML(value=explanation),
                widgets.HBox([self.btn_plot, self.btn_export, self.btn_back]),
                self.out
            ])

    def display(self):
        clear_output(wait=True)
        display(self.main_ui)

    def _on_plot(self, _):
        with self.out:
            clear_output()

            if not self.arrhenius_results:
                exibir_erro("[ERRO] Nenhum resultado de Arrhenius encontrado. Execute o cálculo no módulo anterior.")
                return

            dens_map = defaultdict(list)
            for ensaio, arr_list in self.arrhenius_results.items():
                for dens, invT, lnVal in arr_list:
                    if not np.isfinite(dens) or not np.isfinite(invT) or not np.isfinite(lnVal):
                        continue
                    dens_map[round(dens, 2)].append((invT, lnVal))

            if not dens_map:
                exibir_erro("[ERRO] Não há dados válidos para plotar.")
                return

            fig, ax = plt.subplots(figsize=(8, 6))
            ax.set_title("Arrhenius por Nível de Densidade")
            ax.set_xlabel("1/T (K⁻¹)")
            ax.set_ylabel("ln[(dρ/dt)/T]")

            results = []
            for dens, points in sorted(dens_map.items()):
                if len(points) < 2:
                    continue
                x_vals = np.array([pt[0] for pt in points])
                y_vals = np.array([pt[1] for pt in points])

                try:
                    slope, intercept, r_val, *_ = linregress(x_vals, y_vals)
                    if r_val**2 < 0.8:
                        continue
                    Ea_calc = -slope * R / 1000  # converte para kJ/mol
                except Exception as e:
                    exibir_erro(f"[ERRO] Regressão falhou para densidade {dens}%: {e}")
                    continue

                ax.plot(x_vals, y_vals, 'o', label=f"ρ={dens}% (R²={r_val**2:.2f})")
                fit_x = np.array([x_vals.min(), x_vals.max()])
                ax.plot(fit_x, slope * fit_x + intercept, '-', label=None)
                results.append((dens, Ea_calc, r_val**2))

            if not results:
                exibir_erro("[ERRO] Pontos insuficientes para regressão confiável.")
                return

            ax.legend(bbox_to_anchor=(1.05,1), loc='upper left')
            ax.grid(True)
            plt.tight_layout()
            display(fig)

            # Monta DataFrame de resultados
            self.results_df = pd.DataFrame(results, columns=["Densidade(%)", "Ea (kJ/mol)", "R_quadrado"])
            self.btn_export.disabled = False

            display(HTML(self.results_df.to_html(index=False, float_format="{:.2f}".format)))

    def _on_export(self, _):
        with self.out:
            clear_output()
            if self.results_df is None or self.results_df.empty:
                exibir_erro("[ERRO] Nenhum resultado para exportar.")
                return
            exibir_mensagem("[INFO] Exportando tabela de Ea...")
            link = gerar_link_download(self.results_df, nome_arquivo="Arrhenius_Ea_Table.xlsx")
            display(link)
            exibir_mensagem("[INFO] Exportação concluída.")

    def _on_back_clicked(self, _):
        with self.out:
            clear_output()
            exibir_mensagem("[INFO] Retornando...")
        # Navega conforme controlador
        if self.parent and hasattr(self.parent, 'show_module_by_step'):
            # Go back to Method Choice ('METHOD_CHOICE')
            self.parent.show_module_by_step('METHOD_CHOICE')
        elif self.parent and hasattr(self.parent, 'display'):
            self.parent.display()
        else:
            exibir_erro("[ERRO] Método de retorno não definido.")

import sys
sys.modules['modulo6_1_arrhenius_display'] = sys.modules[__name__]

# MÓDULO Data History
import copy
import datetime
import ipywidgets as widgets # Import widgets
from IPython.display import display # Import display

class DataHistory:
    """
    Classe para armazenar o histórico dos DataFrames.

    Cada registro armazena:
      - A cópia profunda do DataFrame (para evitar alterações futuras)
      - O nome do módulo de onde os dados vieram
      - Os nomes das colunas no momento do armazenamento
      - Um timestamp indicando quando o estado foi salvo.
    """
    # Add optional output_widget parameter
    def __init__(self, output_widget=None):
        self.history = []  # Lista para armazenar os registros de histórico
        self.output_widget = output_widget # Store the output widget

    def push(self, data, module_name: str):
        """
        Salva uma cópia do DataFrame 'data', juntamente com informações do módulo.

        Args:
            data (pd.DataFrame): O DataFrame a ser armazenar.
            module_name (str): Identificador do módulo de origem.
        """
        timestamp = datetime.datetime.now()
        record = {
            'timestamp': timestamp,
            'module': module_name,
            'columns': list(data.columns),
            'data': copy.deepcopy(data)
        }
        self.history.append(record)
        # Log amigável para o usuário, using the provided output_widget if available
        log_message = f"[HISTORY] [{timestamp:%Y-%m-%d %H:%M:%S}] Salvado: '{module_name}' com colunas {record['columns']}"
        if self.output_widget:
            with self.output_widget: # Use the output widget context
                print(log_message)
        else:
            print(log_message) # Fallback to standard output

    def pop(self):
        """
        Remove e retorna o registro mais recente do histórico.

        Returns:
            dict | None: O registro removido ou None se histórico vazio.
        """
        if not self.history:
            log_message = "[HISTORY] Histórico vazio. Nada a restaurar."
            if self.output_widget:
                 with self.output_widget:
                     print(log_message)
            else:
                print(log_message)
            return None
        record = self.history.pop()
        ts = record['timestamp']
        log_message = f"[HISTORY] Removido: '{record['module']}' salvo em {ts:%Y-%m-%d %H:%M:%S}"
        if self.output_widget:
             with self.output_widget:
                 print(log_message)
        else:
            print(log_message)
        return record

    def peek(self):
        """
        Retorna o registro mais recente sem removê-lo.

        Returns:
            dict | None: O registro mais recente ou None se histórico vazio.
        """
        if not self.history:
            return None
        return self.history[-1]

    def get_all(self):
        """
        Retorna todos os registros de histórico.

        Returns:
            list: Lista de registros de histórico.
        """
        return list(self.history)

import ipywidgets as widgets
from IPython.display import display, clear_output

# Import de todos os módulos da aplicação
from core import exibir_mensagem, exibir_erro
from modulo2_importacao import Modulo2Importacao
from modulo3_filtrorecorte import Modulo3Recorte
from modulo4_logtheta import ModuloLogTheta
from modulo5_1_alinhamento import Modulo5_1Alinhamento
from modulo5_2_blaine import Modulo5_2BlaineParameters
from modulo5_3_sigmoides import Modulo5_3Sigmoides
from modulo5_3_1_revisao import Modulo5_3_1_Revisao
from modulo5_4_roteador import Modulo5_4_Roteador
from modulo5_5_refinamento import Modulo5_5_Refinamento
from modulo6_0_arrhenius import Modulo6_0_Arrhenius
from modulo6_1_arrhenius_display import Modulo6_1ArrheniusDisplay

class MainInteractive:
    """
    Controlador principal com layout de duas colunas, navegação completa
    e fluxo de trabalho para LogTheta e Arrhenius.
    """
    def __init__(self):
        self.reiniciar_aplicacao(primeira_vez=True)

    def _build_ui(self):
        """Constrói os widgets da interface, que são reutilizados."""
        self.step_label = widgets.Label()

        # Dicionários separados para botões de cima e de baixo
        self.top_nav_buttons = {
            'back': widgets.Button(description="Etapa Anterior", button_style='warning', icon='arrow-left'),
            'next': widgets.Button(description="Próxima Etapa", button_style='success', icon='arrow-right'),
            'restart': widgets.Button(description="Reiniciar", button_style='danger', icon='refresh')
        }
        self.bottom_nav_buttons = {
            'back': widgets.Button(description="Etapa Anterior", button_style='warning', icon='arrow-left'),
            'next': widgets.Button(description="Próxima Etapa", button_style='success', icon='arrow-right'),
            'restart': widgets.Button(description="Reiniciar", button_style='danger', icon='refresh')
        }

        # Conecta os callbacks para ambos os conjuntos de botões
        for btn_set in [self.top_nav_buttons, self.bottom_nav_buttons]:
            btn_set['next'].on_click(self._on_next_step)
            btn_set['back'].on_click(self._on_back_step)
            btn_set['restart'].on_click(lambda b: self.reiniciar_aplicacao())

        # Contêineres para o layout de duas colunas
        self.controls_container = widgets.VBox(layout={'width': '50%'})
        self.figure_container = widgets.VBox(layout={'width': '50%'})
        self.display_area = widgets.HBox([self.controls_container, self.figure_container])

        self.log_area = widgets.Output()

        nav_bar_top = widgets.HBox(list(self.top_nav_buttons.values()))
        nav_bar_bottom = widgets.HBox(list(self.bottom_nav_buttons.values()))

        self.main_ui = widgets.VBox([
            nav_bar_top, self.step_label, self.display_area, self.log_area, nav_bar_bottom
        ])

    def reiniciar_aplicacao(self, primeira_vez=False):
        """Limpa todo o estado da aplicação e retorna ao passo inicial."""
        if primeira_vez:
            self._build_ui()

        # Resetar estado interno
        self.dfs_from_mod2, self.dfs_from_mod3, self.arrhenius_results = None, None, None
        self.sintering_records = []
        self.analysis_choice = 'logtheta'
        self.current_step_name = 'INTRO'
        self.modules = {}

        with self.log_area: clear_output(wait=True)
        if not primeira_vez:
            exibir_mensagem("Aplicação reiniciada.")

        self.show_module_by_step('INTRO')

    def display(self):
        display(self.main_ui)

    def _update_nav_buttons(self):
        # ... (A lógica de _update_nav_buttons permanece como na versão anterior,
        # agora atuando sobre os dois conjuntos de botões) ...
        pass # Placeholder for the actual implementation

    def _on_next_step(self, _=None):
        with self.log_area: clear_output(wait=True)

        if self.current_step_name == 'IMPORT':
            # Chama a função de validação correta
            if not self.modules.get('mod2') or not self.modules['mod2'].validar_etapa():
                exibir_erro("Validação da Etapa 1 falhou. Verifique as mensagens de erro e tente novamente.")
                return

        current_index = self.step_sequence.index(self.current_step_name)
        if current_index < len(self.step_sequence) - 1:
            self.show_module_by_step(self.step_sequence[current_index + 1])

    def _on_back_step(self, _=None):
        # ... (A lógica de _on_back_step permanece a mesma) ...
        pass # Placeholder for the actual implementation


    def show_module_by_step(self, step_name: str):
        self.current_step_name = step_name
        self.controls_container.children = ()
        # Limpa o contêiner de figuras, exceto para o Módulo 3 que tem seu próprio layout
        if step_name != 'FILTER':
            self.figure_container.children = ()
            self.display_area.children = [self.controls_container, self.figure_container]

        self.step_sequence = [
            'INTRO', 'IMPORT', 'FILTER', 'METHOD_CHOICE', 'CALCULATION',
            'POST_PROCESSING', 'BLAINE', 'FIT_SELECTION', 'REVIEW',
            'FINAL_ANALYSIS', 'REFINEMENT'
        ]

        step_labels = {
            'INTRO': "Passo 0: Introdução", 'IMPORT': "Passo 1: Importar e Mapear Dados",
            'FILTER': "Passo 2: Recortar e Filtrar Dados", 'METHOD_CHOICE': "Passo 3: Escolher Método de Análise",
            'CALCULATION': f"Passo 4: Cálculo Principal ({self.analysis_choice.title()})",
            'POST_PROCESSING': f"Passo 5: Análise dos Resultados ({self.analysis_choice.title()})",
            'BLAINE': "Passo 5.2: Calcular Parâmetros de Blaine",
            'FIT_SELECTION': "Passo 5.3: Selecionar Dados para Ajuste", 'REVIEW': "Passo 5.3.1: Revisar Ajustes",
            'FINAL_ANALYSIS': "Passo 5.4: Análise Final e Busca da Melhor Ea",
            'REFINEMENT': "Passo 5.5: Refinamento da Energia de Ativação"
        }
        self.step_labels = step_labels # Store step_labels for show_refinement_module

        step_runners = {
            'INTRO': self._show_intro, 'IMPORT': self._show_import, 'FILTER': self._show_filter,
            'METHOD_CHOICE': self._show_method_choice,
            'CALCULATION': self._run_calculation, 'POST_PROCESSING': self._run_post_processing,
            'BLAINE': self._show_blaine, 'FIT_SELECTION': self._show_fit_selection,
            'REVIEW': self._run_fit_and_show_review, 'FINAL_ANALYSIS': self._show_final_analysis_router,
            'REFINEMENT': self.show_refinement_module
        }

        self.step_label.value = step_labels.get(step_name, "Etapa Desconhecida")
        action = step_runners.get(step_name)
        if action: action()
        self._update_nav_buttons()

    # --- Funções de construção para cada passo ---
    def _show_intro(self):
        intro_html = "<h1>Bem-vindo ao Ogum Sintering!</h1><p>Clique em 'Próxima Etapa' para começar.</p>"
        self.controls_container.children = (widgets.HTML(intro_html),)

    def _show_import(self):
        if 'mod2' not in self.modules: self.modules['mod2'] = Modulo2Importacao()
        self.controls_container.children = (self.modules['mod2'].main_ui,)

    def _show_filter(self):
        self.dfs_from_mod2 = self.modules['mod2'].get_dfs()
        self.modules['mod3'] = Modulo3Recorte(self.dfs_from_mod2)
        # Módulo 3 ocupa toda a área de display com seu próprio layout HBox
        self.display_area.children = [self.modules['mod3'].main_ui]

    def _show_method_choice(self):
        self.dfs_from_mod3 = self.modules['mod3'].get_dfs()
        radio = widgets.RadioButtons(options=[("Curva Mestra (LogTheta)", "logtheta"), ("Arrhenius", "arrhenius")], description="Método:")
        btn = widgets.Button(description="Confirmar e Continuar", button_style='info')
        def on_confirm(_):
            self.analysis_choice = radio.value
            self.show_module_by_step('CALCULATION')
        btn.on_click(on_confirm)
        self.controls_container.children = (widgets.VBox([widgets.HTML("<h3>Escolha o método de análise:</h3>"), radio, btn]),)

    def _run_calculation(self):
        if self.analysis_choice == 'logtheta':
            self.modules['logtheta'] = ModuloLogTheta(self.dfs_from_mod3, fig_out=self.figure_container)
            self.controls_container.children = (self.modules['logtheta'].ui,)
        else: # Arrhenius
            self.modules['arrhenius_calc'] = Modulo6_0_Arrhenius(self.dfs_from_mod3)
            self.controls_container.children = (self.modules['arrhenius_calc'].main_ui,)

    def _run_post_processing(self):
        if self.analysis_choice == 'logtheta':
            self.sintering_records = self.modules['logtheta'].get_sintering_records()
            self.modules['align'] = Modulo5_1Alinhamento(self.sintering_records)
            self.controls_container.children = (self.modules['align'].main_ui,)
        else: # Arrhenius
            self.arrhenius_results = self.modules['arrhenius_calc'].get_results()
            n_ensaios = len(self.modules['mod2'].get_dfs())
            self.modules['arrhenius_disp'] = Modulo6_1ArrheniusDisplay(self.arrhenius_results, n_ensaios, parent=self)
            self.controls_container.children = (self.modules['arrhenius_disp'].main_ui,)

    def _show_blaine(self):
        self.sintering_records = self.modules['align'].get_aligned_records()
        self.modules['blaine'] = Modulo5_2BlaineParameters(self.sintering_records, fig_out=self.figure_container)
        self.controls_container.children = (self.modules['blaine'].main_ui,)

    def _show_fit_selection(self):
        self.sintering_records = self.modules['blaine'].get_blaine_records()
        self.modules['sigmoidal'] = Modulo5_3Sigmoides(self.sintering_records)
        self.controls_container.children = (self.modules['sigmoidal'].main_ui,)

    def _run_fit_and_show_review(self, p0_overrides=None):
        mod_sigmoidal = self.modules['sigmoidal']
        if not p0_overrides:
            ui_selection = mod_sigmoidal.select_data.value
            if not ui_selection:
                exibir_erro("Nenhum tipo de dado foi selecionado para o ajuste."); self.show_module_by_step('FIT_SELECTION'); return
            types_to_fit = [mod_sigmoidal.DATA_OPTIONS_MAP[ui_name] for ui_name in ui_selection]
        else:
            types_to_fit = list(set(key[2] for key in p0_overrides.keys()))

        with self.log_area: clear_output(wait=True)
        mod_sigmoidal.run_all_fits(types_to_fit, p0_overrides)
        self.sintering_records = mod_sigmoidal.get_all_records_after_fit()

        self.modules['review'] = Modulo5_3_1_Revisao(self.sintering_records, controller=self)
        self.controls_container.children = (self.modules['review'].main_ui,)

    def _show_final_analysis_router(self):
        self.modules['router5_4'] = Modulo5_4_Roteador(self.sintering_records, controller=self)
        self.controls_container.children = (self.modules['router5_4'].main_ui,)

    def show_refinement_module(self, initial_ea, target_curve_type):
        self.current_step_name = 'REFINEMENT'
        self.step_label.value = self.step_labels['REFINEMENT']
        self.modules['refinement'] = Modulo5_5_Refinamento(
            sintering_records=self.sintering_records, initial_ea=initial_ea,
            target_curve_type=target_curve_type, parent=self
        )
        self.controls_container.children = (self.modules['refinement'].main_ui,)
        self._update_nav_buttons()

    def trigger_refit(self, p0_overrides):
        self._run_fit_and_show_review(p0_overrides=p0_overrides)

sys.modules['main_interactive'] = sys.modules[__name__]
main_app = MainInteractive()
main_app.display()

# Lembre-se de adicionar a linha sys.modules['main_interactive'] = sys.modules[__name__]
# ao final da sua célula no notebook, se ainda não o fez.

import ipywidgets as widgets
from IPython.display import display, clear_output

# Import de todos os módulos da aplicação
from core import exibir_mensagem, exibir_erro, criar_caixa_colapsavel
from modulo2_importacao import Modulo2Importacao
from modulo3_filtrorecorte import Modulo3Recorte
from modulo4_logtheta import ModuloLogTheta
from modulo5_1_alinhamento import Modulo5_1Alinhamento
from modulo5_2_blaine import Modulo5_2BlaineParameters
from modulo5_3_sigmoides import Modulo5_3Sigmoides
from modulo5_3_1_revisao import Modulo5_3_1_Revisao
from modulo5_4_roteador import Modulo5_4_Roteador
from modulo5_5_refinamento import Modulo5_5_Refinamento
from modulo6_0_arrhenius import Modulo6_0_Arrhenius
from modulo6_1_arrhenius_display import Modulo6_1ArrheniusDisplay

class MainInteractive:
    """
    Controlador principal com layout de duas colunas, navegação completa
    e logs organizados em uma seção colapsável.
    """
    def __init__(self):
        self.reiniciar_aplicacao(primeira_vez=True)

    def _build_ui(self):
        """Constrói os widgets da interface, que são reutilizados."""
        self.step_label = widgets.Label()

        # Dicionários separados para botões de cima e de baixo
        self.top_nav_buttons = {
            'back': widgets.Button(description="Etapa Anterior", button_style='warning', icon='arrow-left'),
            'next': widgets.Button(description="Próxima Etapa", button_style='success', icon='arrow-right'),
            'restart': widgets.Button(description="Reiniciar", button_style='danger', icon='refresh')
        }
        self.bottom_nav_buttons = {
            'back': widgets.Button(description="Etapa Anterior", button_style='warning', icon='arrow-left'),
            'next': widgets.Button(description="Próxima Etapa", button_style='success', icon='arrow-right'),
            'restart': widgets.Button(description="Reiniciar", button_style='danger', icon='refresh')
        }

        for btn_set in [self.top_nav_buttons, self.bottom_nav_buttons]:
            btn_set['next'].on_click(self._on_next_step)
            btn_set['back'].on_click(self._on_back_step)
            btn_set['restart'].on_click(lambda b: self.reiniciar_aplicacao())

        # Contêineres para o layout
        self.controls_container = widgets.VBox(layout={'width': '50%'})
        self.figure_container = widgets.VBox(layout={'width': '50%'})
        self.display_area = widgets.HBox([self.controls_container, self.figure_container])

        self.log_area = widgets.Output()
        self.history_area = widgets.Output()

        # Envolve as saídas de log e histórico em uma caixa colapsável
        log_and_history_box = widgets.VBox([
            widgets.HTML("<b>Logs da Sessão:</b>"), self.log_area,
            widgets.HTML("<hr><b>Histórico de Dados:</b>"), self.history_area
        ])
        self.log_accordion = criar_caixa_colapsavel("Ver/Ocultar Logs e Histórico", log_and_history_box, aberto=False)

        nav_bar_top = widgets.HBox(list(self.top_nav_buttons.values()))
        nav_bar_bottom = widgets.HBox(list(self.bottom_nav_buttons.values()))

        self.main_ui = widgets.VBox([
            nav_bar_top, self.step_label, self.display_area, self.log_accordion, nav_bar_bottom
        ])

    def reiniciar_aplicacao(self, primeira_vez=False):
        """Limpa todo o estado da aplicação e retorna ao passo inicial."""
        if primeira_vez:
            self._build_ui()

        self.dfs_from_mod2, self.dfs_from_mod3, self.arrhenius_results = None, None, None
        self.sintering_records = []
        self.analysis_choice = 'logtheta'
        self.current_step_name = 'INTRO'
        self.modules = {}

        with self.log_area: clear_output(wait=True)
        with self.history_area: clear_output(wait=True)
        if not primeira_vez:
            exibir_mensagem("Aplicação reiniciada.")

        self.show_module_by_step('INTRO')

    def display(self):
        display(self.main_ui)

    def _update_nav_buttons(self):
        current_index = self.step_sequence.index(self.current_step_name)
        back_disabled = (current_index <= self.step_sequence.index('IMPORT'))

        interactive_steps = ['METHOD_CHOICE', 'REVIEW', 'FINAL_ANALYSIS', 'REFINEMENT']
        is_final_arrhenius_step = (self.analysis_choice == 'arrhenius' and self.current_step_name == 'POST_PROCESSING')
        next_disabled = (self.current_step_name in interactive_steps) or is_final_arrhenius_step

        for btn_set in [self.top_nav_buttons, self.bottom_nav_buttons]:
            btn_set['back'].disabled = back_disabled
            btn_set['next'].disabled = next_disabled

    def _on_next_step(self, _=None):
        with self.log_area: clear_output(wait=True)

        if self.current_step_name == 'IMPORT':
            if not self.modules.get('mod2') or not self.modules['mod2'].validar_etapa():
                exibir_erro("Validação da Etapa 1 falhou. Verifique as mensagens de erro e tente novamente.")
                return

        current_index = self.step_sequence.index(self.current_step_name)
        if current_index < len(self.step_sequence) - 1:
            self.show_module_by_step(self.step_sequence[current_index + 1])

    def _on_back_step(self, _=None):
        with self.log_area: clear_output(wait=True)
        current_index = self.step_sequence.index(self.current_step_name)
        if current_index > 0:
            if self.current_step_name in ['CALCULATION', 'POST_PROCESSING']:
                self.show_module_by_step('METHOD_CHOICE')
            else:
                self.show_module_by_step(self.step_sequence[current_index - 1])

    def show_module_by_step(self, step_name: str):
        self.current_step_name = step_name
        self.controls_container.children = ()
        if step_name != 'FILTER':
            self.figure_container.children = ()
            self.display_area.children = [self.controls_container, self.figure_container]

        self.step_sequence = [
            'INTRO', 'IMPORT', 'FILTER', 'METHOD_CHOICE', 'CALCULATION',
            'POST_PROCESSING', 'BLAINE', 'FIT_SELECTION', 'REVIEW',
            'FINAL_ANALYSIS', 'REFINEMENT'
        ]

        step_labels = {
            'INTRO': "Passo 0: Introdução", 'IMPORT': "Passo 1: Importar e Mapear Dados",
            'FILTER': "Passo 2: Recortar e Filtrar Dados", 'METHOD_CHOICE': "Passo 3: Escolher Método de Análise",
            'CALCULATION': f"Passo 4: Cálculo Principal ({self.analysis_choice.title()})",
            'POST_PROCESSING': f"Passo 5: Análise dos Resultados ({self.analysis_choice.title()})",
            'BLAINE': "Passo 5.2: Calcular Parâmetros de Blaine",
            'FIT_SELECTION': "Passo 5.3: Selecionar Dados para Ajuste", 'REVIEW': "Passo 5.3.1: Revisar Ajustes",
            'FINAL_ANALYSIS': "Passo 5.4: Análise Final e Busca da Melhor Ea",
            'REFINEMENT': "Passo 5.5: Refinamento da Energia de Ativação"
        }

        step_runners = {
            'INTRO': self._show_intro, 'IMPORT': self._show_import, 'FILTER': self._show_filter,
            'METHOD_CHOICE': self._show_method_choice,
            'CALCULATION': self._run_calculation, 'POST_PROCESSING': self._run_post_processing,
            'BLAINE': self._show_blaine, 'FIT_SELECTION': self._show_fit_selection,
            'REVIEW': self._run_fit_and_show_review, 'FINAL_ANALYSIS': self._show_final_analysis_router,
            'REFINEMENT': self.show_refinement_module
        }

        self.step_label.value = step_labels.get(step_name, "Etapa Desconhecida")
        action = step_runners.get(step_name)
        if action: action()
        self._update_nav_buttons()

    def _show_intro(self):
        intro_html = "<h1>Bem-vindo ao Ogum Sintering!</h1><p>Clique em 'Próxima Etapa' para começar.</p>"
        self.controls_container.children = (widgets.HTML(intro_html),)

    def _show_import(self):
        if 'mod2' not in self.modules: self.modules['mod2'] = Modulo2Importacao()
        self.controls_container.children = (self.modules['mod2'].main_ui,)

    def _show_filter(self):
        self.dfs_from_mod2 = self.modules['mod2'].get_dfs()
        self.modules['mod3'] = Modulo3Recorte(self.dfs_from_mod2)
        self.display_area.children = [self.modules['mod3'].main_ui]

    def _show_method_choice(self):
        self.dfs_from_mod3 = self.modules['mod3'].get_dfs()
        radio = widgets.RadioButtons(options=[("Curva Mestra (LogTheta)", "logtheta"), ("Arrhenius", "arrhenius")], description="Método:")
        btn = widgets.Button(description="Confirmar e Continuar", button_style='info')
        def on_confirm(_):
            self.analysis_choice = radio.value
            self.show_module_by_step('CALCULATION')
        btn.on_click(on_confirm)
        self.controls_container.children = (widgets.VBox([widgets.HTML("<h3>Escolha o método de análise:</h3>"), radio, btn]),)

    def _run_calculation(self):
        if self.analysis_choice == 'logtheta':
            self.modules['logtheta'] = ModuloLogTheta(self.dfs_from_mod3, fig_out=self.figure_container)
            self.controls_container.children = (self.modules['logtheta'].ui,)
        else:
            self.modules['arrhenius_calc'] = Modulo6_0_Arrhenius(self.dfs_from_mod3)
            self.controls_container.children = (self.modules['arrhenius_calc'].main_ui,)

    def _run_post_processing(self):
        if self.analysis_choice == 'logtheta':
            self.sintering_records = self.modules['logtheta'].get_sintering_records()
            self.modules['align'] = Modulo5_1Alinhamento(self.sintering_records)
            self.controls_container.children = (self.modules['align'].main_ui,)
        else:
            self.arrhenius_results = self.modules['arrhenius_calc'].get_results()
            n_ensaios = len(self.modules['mod2'].get_dfs())
            self.modules['arrhenius_disp'] = Modulo6_1ArrheniusDisplay(self.arrhenius_results, n_ensaios, parent=self)
            self.controls_container.children = (self.modules['arrhenius_disp'].main_ui,)

    def _show_blaine(self):
        self.sintering_records = self.modules['align'].get_aligned_records()
        self.modules['blaine'] = Modulo5_2BlaineParameters(self.sintering_records, fig_out=self.figure_container)
        self.controls_container.children = (self.modules['blaine'].main_ui,)

    def _show_fit_selection(self):
        self.sintering_records = self.modules['blaine'].get_blaine_records()
        self.modules['sigmoidal'] = Modulo5_3Sigmoides(self.sintering_records)
        self.controls_container.children = (self.modules['sigmoidal'].main_ui,)

    def _run_fit_and_show_review(self, p0_overrides=None):
        mod_sigmoidal = self.modules['sigmoidal']
        if not p0_overrides:
            ui_selection = mod_sigmoidal.select_data.value
            if not ui_selection:
                exibir_erro("Nenhum tipo de dado selecionado."); self.show_module_by_step('FIT_SELECTION'); return
            types_to_fit = [mod_sigmoidal.DATA_OPTIONS_MAP[ui_name] for ui_name in ui_selection]
        else:
            types_to_fit = list(set(key[2] for key in p0_overrides.keys()))

        with self.log_area: clear_output(wait=True)
        mod_sigmoidal.run_all_fits(types_to_fit, p0_overrides)
        self.sintering_records = mod_sigmoidal.get_all_records_after_fit()

        self.modules['review'] = Modulo5_3_1_Revisao(self.sintering_records, controller=self)
        self.controls_container.children = (self.modules['review'].main_ui,)

    def _show_final_analysis_router(self):
        self.modules['router5_4'] = Modulo5_4_Roteador(self.sintering_records, controller=self, fig_out=self.figure_container)
        self.controls_container.children = (self.modules['router5_4'].main_ui,)

    def show_refinement_module(self, initial_ea, target_curve_type):
        self.current_step_name = 'REFINEMENT'
        self.step_label.value = self.step_labels['REFINEMENT']
        self.modules['refinement'] = Modulo5_5_Refinamento(
            sintering_records=self.sintering_records, initial_ea=initial_ea,
            target_curve_type=target_curve_type, parent=self, fig_out=self.figure_container
        )
        self.controls_container.children = (self.modules['refinement'].main_ui,)
        self._update_nav_buttons()

    def trigger_refit(self, p0_overrides):
        self._run_fit_and_show_review(p0_overrides=p0_overrides)


sys.modules['main_interactive'] = sys.modules[__name__]
main_app = MainInteractive()
main_app.display()